; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_phase_shift.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_phase_shift.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\USMART -I..\..\User\bsp_stm32f4xx\LCD -I..\..\User\bsp_stm32f4xx\phase_shift -I..\..\User\bsp_stm32f4xx\PWMInput -I..\..\User\bsp_stm32f4xx\ADC -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F427xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\bsp_phase_shift.crf ..\..\User\bsp_stm32f4xx\phase_shift\bsp_phase_shift.c]
                          THUMB

                          AREA ||i.bsp_phase_shift_init||, CODE, READONLY, ALIGN=2

                  bsp_phase_shift_init PROC
;;;8      */
;;;9      void bsp_phase_shift_init(uint16_t frequency,uint16_t phase_shift_duty_cycle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;10     {
000004  ed2d8b0c          VPUSH    {d8-d13}
000008  b08e              SUB      sp,sp,#0x38
00000a  4606              MOV      r6,r0
00000c  460c              MOV      r4,r1
;;;11     	uint16_t TIM1_Period = 0; //填写到ARR寄存器的值
00000e  2500              MOVS     r5,#0
;;;12     	uint32_t TIM8_CH2_Pulse=0,TIM8_CH1_Pulse=0;  //用于存放计算移相后CRR1,CCR2的数值  
000010  46a8              MOV      r8,r5
000012  2700              MOVS     r7,#0
;;;13     	
;;;14     	GPIO_InitTypeDef GPIO_InitStructure;  //GPIO初始化结构体
;;;15     	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;  //定时器基础设置结构体
;;;16     	TIM_OCInitTypeDef  TIM_OCInitStructure;   //定时器输出比较设置结构体
;;;17     	TIM_BDTRInitTypeDef TIM_BDTRInitStructure;   //定时器死区设置结构体（由于仅仅是用了死区，所以称为死区结构体）
;;;18     	
;;;19     	/* TIM8 clock enable */
;;;20         RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
000014  2101              MOVS     r1,#1
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;21     	
;;;22     	/* GPIOA and GPIOB and GPIOC clocks enable */
;;;23     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA |RCC_AHB1Periph_GPIOC|RCC_AHB1Periph_GPIOB, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  2007              MOVS     r0,#7
000020  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;24     	
;;;25     	//配置TIM8 Channel_1(PC6) Channel_1N(PA5) Channel_2(PC7) Channel_2N(PB14)
;;;26     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
000024  20c0              MOVS     r0,#0xc0
000026  900c              STR      r0,[sp,#0x30]
;;;27     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000028  2002              MOVS     r0,#2
00002a  f88d0034          STRB     r0,[sp,#0x34]
;;;28     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0035          STRB     r0,[sp,#0x35]
;;;29     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000034  2000              MOVS     r0,#0
000036  f88d0036          STRB     r0,[sp,#0x36]
;;;30     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
00003a  2001              MOVS     r0,#1
00003c  f88d0037          STRB     r0,[sp,#0x37]
;;;31     	GPIO_Init(GPIOC, &GPIO_InitStructure);
000040  a90c              ADD      r1,sp,#0x30
000042  4875              LDR      r0,|L1.536|
000044  f7fffffe          BL       GPIO_Init
;;;32     	
;;;33     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 ;
000048  2020              MOVS     r0,#0x20
00004a  900c              STR      r0,[sp,#0x30]
;;;34     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00004c  a90c              ADD      r1,sp,#0x30
00004e  4873              LDR      r0,|L1.540|
000050  f7fffffe          BL       GPIO_Init
;;;35     	
;;;36     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
000054  f44f4080          MOV      r0,#0x4000
000058  900c              STR      r0,[sp,#0x30]
;;;37     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00005a  a90c              ADD      r1,sp,#0x30
00005c  4870              LDR      r0,|L1.544|
00005e  f7fffffe          BL       GPIO_Init
;;;38     	
;;;39     	/* Connect TIM pins to AF3 */
;;;40     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_TIM8);
000062  2203              MOVS     r2,#3
000064  2105              MOVS     r1,#5
000066  486d              LDR      r0,|L1.540|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;41     	GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_TIM8);
00006c  2203              MOVS     r2,#3
00006e  2106              MOVS     r1,#6
000070  4869              LDR      r0,|L1.536|
000072  f7fffffe          BL       GPIO_PinAFConfig
;;;42     	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_TIM8);
000076  2203              MOVS     r2,#3
000078  2107              MOVS     r1,#7
00007a  4867              LDR      r0,|L1.536|
00007c  f7fffffe          BL       GPIO_PinAFConfig
;;;43     	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_TIM8);
000080  2203              MOVS     r2,#3
000082  210e              MOVS     r1,#0xe
000084  4866              LDR      r0,|L1.544|
000086  f7fffffe          BL       GPIO_PinAFConfig
;;;44     	
;;;45     	/*TIM8 input clock (TIM8CLK) is set to 2 * APB2 clock (PCLK2), since APB2 
;;;46         prescaler is different from 1.   
;;;47         TIM1CLK = 2 * PCLK2  
;;;48         PCLK2 = HCLK / 2 
;;;49         => TIM8CLK = 2 * (HCLK / 2) = HCLK = SystemCoreClock
;;;50       
;;;51         TIM8CLK is fixed to SystemCoreClock, the TIM8 Prescaler is equal to 0 so the 
;;;52         TIM8 counter clock used is SystemCoreClock (168MHz).
;;;53     
;;;54         The objective is to generate PWM signal at _Frequency KHz:
;;;55         - TIM8_Period = (SystemCoreClock / frequency) - 1   */
;;;56     	
;;;57     	//由于输出模式设置为翻转模式，在一次CNT计数满ARR值中只翻转一次，故输出想输出
;;;58     	//PWM频率到达函数形参传进来的数值，下面的公式需要乘2
;;;59     	TIM1_Period = ( SystemCoreClock / (frequency * 2) ) - 1;
00008a  0070              LSLS     r0,r6,#1
00008c  4965              LDR      r1,|L1.548|
00008e  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000090  fbb1f0f0          UDIV     r0,r1,r0
000094  1e40              SUBS     r0,r0,#1
000096  b285              UXTH     r5,r0
;;;60     	//初始化时ARR=4200
;;;61     	
;;;62     	/* Time Base configuration */
;;;63     	TIM_TimeBaseStructure.TIM_Prescaler = 0;
000098  2000              MOVS     r0,#0
00009a  f8ad0024          STRH     r0,[sp,#0x24]
;;;64     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00009e  f8ad0026          STRH     r0,[sp,#0x26]
;;;65     	TIM_TimeBaseStructure.TIM_Period = TIM1_Period;
0000a2  950a              STR      r5,[sp,#0x28]
;;;66     	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
0000a4  f8ad002c          STRH     r0,[sp,#0x2c]
;;;67         TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
0000a8  a909              ADD      r1,sp,#0x24
0000aa  485f              LDR      r0,|L1.552|
0000ac  f7fffffe          BL       TIM_TimeBaseInit
;;;68     	
;;;69     	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Toggle;
0000b0  2030              MOVS     r0,#0x30
0000b2  f8ad0010          STRH     r0,[sp,#0x10]
;;;70     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
0000b6  2001              MOVS     r0,#1
0000b8  f8ad0012          STRH     r0,[sp,#0x12]
;;;71     	
;;;72     	TIM8_CH1_Pulse = (uint32_t) (((TIM1_Period+1) * ((1000 - phase_shift_duty_cycle)*1.0/1000) - 1) );
0000bc  f5c4707a          RSB      r0,r4,#0x3e8
0000c0  f7fffffe          BL       __aeabi_i2d
0000c4  ec410b1d          VMOV     d13,r0,r1
0000c8  ed9f0b58          VLDR     d0,|L1.556|
0000cc  ec532b10          VMOV     r2,r3,d0
0000d0  f7fffffe          BL       __aeabi_dmul
0000d4  ec410b1c          VMOV     d12,r0,r1
0000d8  ed9f0b56          VLDR     d0,|L1.564|
0000dc  ec532b10          VMOV     r2,r3,d0
0000e0  f7fffffe          BL       __aeabi_ddiv
0000e4  ec410b1a          VMOV     d10,r0,r1
0000e8  1c68              ADDS     r0,r5,#1
0000ea  f7fffffe          BL       __aeabi_i2d
0000ee  ec410b1b          VMOV     d11,r0,r1
0000f2  ec532b1a          VMOV     r2,r3,d10
0000f6  f7fffffe          BL       __aeabi_dmul
0000fa  ec410b19          VMOV     d9,r0,r1
0000fe  ed9f0b4b          VLDR     d0,|L1.556|
000102  ec532b10          VMOV     r2,r3,d0
000106  f7fffffe          BL       __aeabi_dsub
00010a  ec410b18          VMOV     d8,r0,r1
00010e  f7fffffe          BL       __aeabi_d2uiz
000112  4607              MOV      r7,r0
;;;73     	
;;;74     	TIM_OCInitStructure.TIM_Pulse = TIM8_CH1_Pulse;
000114  9706              STR      r7,[sp,#0x18]
;;;75     	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
000116  2000              MOVS     r0,#0
000118  f8ad001c          STRH     r0,[sp,#0x1c]
;;;76     	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
00011c  2004              MOVS     r0,#4
00011e  f8ad0014          STRH     r0,[sp,#0x14]
;;;77     	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;
000122  2000              MOVS     r0,#0
000124  f8ad001e          STRH     r0,[sp,#0x1e]
;;;78     	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;
000128  f8ad0020          STRH     r0,[sp,#0x20]
;;;79     	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
00012c  f8ad0022          STRH     r0,[sp,#0x22]
;;;80     	
;;;81     	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
000130  a904              ADD      r1,sp,#0x10
000132  483d              LDR      r0,|L1.552|
000134  f7fffffe          BL       TIM_OC1Init
;;;82     	TIM_OC1PreloadConfig(TIM8,TIM_OCPreload_Enable);          //输出比较通道1相关预装载寄存器使能  CCME1->OC1PE=1	
000138  2108              MOVS     r1,#8
00013a  483b              LDR      r0,|L1.552|
00013c  f7fffffe          BL       TIM_OC1PreloadConfig
;;;83     	
;;;84     	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
000140  2000              MOVS     r0,#0
000142  f8ad001c          STRH     r0,[sp,#0x1c]
;;;85     	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;
000146  f8ad001e          STRH     r0,[sp,#0x1e]
;;;86     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
00014a  2001              MOVS     r0,#1
00014c  f8ad0012          STRH     r0,[sp,#0x12]
;;;87     	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;	
000150  2004              MOVS     r0,#4
000152  f8ad0014          STRH     r0,[sp,#0x14]
;;;88     	
;;;89     	
;;;90     	//比较通道将产生移相，移相由填进CCR2的数值确定
;;;91     	TIM8_CH2_Pulse = (uint32_t) (((TIM1_Period+1) * (phase_shift_duty_cycle*1.0/100) - 1) );
000156  4620              MOV      r0,r4
000158  f7fffffe          BL       __aeabi_ui2d
00015c  ec410b1d          VMOV     d13,r0,r1
000160  ed9f0b32          VLDR     d0,|L1.556|
000164  ec532b10          VMOV     r2,r3,d0
000168  f7fffffe          BL       __aeabi_dmul
00016c  ec410b1c          VMOV     d12,r0,r1
000170  ed9f0b32          VLDR     d0,|L1.572|
000174  ec532b10          VMOV     r2,r3,d0
000178  f7fffffe          BL       __aeabi_ddiv
00017c  ec410b1a          VMOV     d10,r0,r1
000180  1c68              ADDS     r0,r5,#1
000182  f7fffffe          BL       __aeabi_i2d
000186  ec410b1b          VMOV     d11,r0,r1
00018a  ec532b1a          VMOV     r2,r3,d10
00018e  f7fffffe          BL       __aeabi_dmul
000192  ec410b19          VMOV     d9,r0,r1
000196  ed9f0b25          VLDR     d0,|L1.556|
00019a  ec532b10          VMOV     r2,r3,d0
00019e  f7fffffe          BL       __aeabi_dsub
0001a2  ec410b18          VMOV     d8,r0,r1
0001a6  f7fffffe          BL       __aeabi_d2uiz
0001aa  4680              MOV      r8,r0
;;;92     	TIM_OCInitStructure.TIM_Pulse = 0;
0001ac  2000              MOVS     r0,#0
0001ae  9006              STR      r0,[sp,#0x18]
;;;93     	
;;;94     	TIM_OC2Init(TIM8, &TIM_OCInitStructure);
0001b0  a904              ADD      r1,sp,#0x10
0001b2  481d              LDR      r0,|L1.552|
0001b4  f7fffffe          BL       TIM_OC2Init
;;;95     	TIM_OC2PreloadConfig(TIM8,TIM_OCPreload_Enable);
0001b8  2108              MOVS     r1,#8
0001ba  481b              LDR      r0,|L1.552|
0001bc  f7fffffe          BL       TIM_OC2PreloadConfig
;;;96     	
;;;97     	/*互补PWM死区与断路设置*/
;;;98         TIM_BDTRInitStructure.TIM_AutomaticOutput=TIM_AutomaticOutput_Disable;   //关闭自动使能输出，MOE只能由软件置1 BDTR->AOE=0
0001c0  2000              MOVS     r0,#0
0001c2  f8ad000c          STRH     r0,[sp,#0xc]
;;;99         TIM_BDTRInitStructure.TIM_Break=TIM_Break_Disable;                       //禁止短路输入  BDTE->BKE=0
0001c6  f8ad0008          STRH     r0,[sp,#8]
;;;100        TIM_BDTRInitStructure.TIM_BreakPolarity=TIM_BreakPolarity_High;
0001ca  f44f5000          MOV      r0,#0x2000
0001ce  f8ad000a          STRH     r0,[sp,#0xa]
;;;101        TIM_BDTRInitStructure.TIM_DeadTime=80;// DT*(1/168M)     死区时间       BDTR->DGT=TIM_DeadTime
0001d2  2050              MOVS     r0,#0x50
0001d4  f8ad0006          STRH     r0,[sp,#6]
;;;102    	TIM_BDTRInitStructure.TIM_LOCKLevel=TIM_LOCKLevel_OFF;   // 关闭锁定
0001d8  2000              MOVS     r0,#0
0001da  f8ad0004          STRH     r0,[sp,#4]
;;;103        TIM_BDTRInitStructure.TIM_OSSIState=TIM_OSSIState_Enable;   //空闲模式下的关闭状态选择写1
0001de  f44f6080          MOV      r0,#0x400
0001e2  f8ad0002          STRH     r0,[sp,#2]
;;;104        TIM_BDTRInitStructure.TIM_OSSRState=TIM_OSSRState_Enable;   //运行模式下的关闭状态选择写1
0001e6  0040              LSLS     r0,r0,#1
0001e8  f8ad0000          STRH     r0,[sp,#0]
;;;105        TIM_BDTRConfig(TIM8,&TIM_BDTRInitStructure); 
0001ec  4669              MOV      r1,sp
0001ee  480e              LDR      r0,|L1.552|
0001f0  f7fffffe          BL       TIM_BDTRConfig
;;;106    	
;;;107    	 /* Main Output Enable */
;;;108        TIM_CtrlPWMOutputs(TIM8, ENABLE);
0001f4  2101              MOVS     r1,#1
0001f6  480c              LDR      r0,|L1.552|
0001f8  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;109    	
;;;110    	TIM_CCPreloadControl(TIM8,ENABLE);  //CR2->CCPC=1
0001fc  2101              MOVS     r1,#1
0001fe  480a              LDR      r0,|L1.552|
000200  f7fffffe          BL       TIM_CCPreloadControl
;;;111    	
;;;112    	/* TIM enable counter */
;;;113        TIM_Cmd(TIM8,ENABLE);
000204  2101              MOVS     r1,#1
000206  4808              LDR      r0,|L1.552|
000208  f7fffffe          BL       TIM_Cmd
;;;114       
;;;115    }
00020c  b00e              ADD      sp,sp,#0x38
00020e  ecbd8b0c          VPOP     {d8-d13}
000212  e8bd81f0          POP      {r4-r8,pc}
;;;116    
                          ENDP

000216  0000              DCW      0x0000
                  |L1.536|
                          DCD      0x40020800
                  |L1.540|
                          DCD      0x40020000
                  |L1.544|
                          DCD      0x40020400
                  |L1.548|
                          DCD      SystemCoreClock
                  |L1.552|
                          DCD      0x40010400
                  |L1.556|
00022c  00000000          DCFD     0x3ff0000000000000 ; 1
000230  3ff00000
                  |L1.564|
000234  00000000          DCFD     0x408f400000000000 ; 1000
000238  408f4000
                  |L1.572|
00023c  00000000          DCFD     0x4059000000000000 ; 100
000240  40590000

                          AREA ||i.bsp_set_phase_shift_duty_cycle||, CODE, READONLY, ALIGN=2

                  bsp_set_phase_shift_duty_cycle PROC
;;;120    */
;;;121    void bsp_set_phase_shift_duty_cycle(uint16_t phase_shift_duty_cycle)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  ed2d8b0c          VPUSH    {d8-d13}
000006  4604              MOV      r4,r0
;;;123    	uint16_t arr_value;  //用于存放当前的arr寄存器的数值
;;;124    //	uint32_t TIM1_CH2_Pulse=0;  //用于存放计算移相后CCR2的数值
;;;125    //	arr_value = TIM1 -> ARR;
;;;126    //	printf("Current arr register value = %d \r\n",arr_value);
;;;127    //	TIM1_CH2_Pulse = (uint32_t) ((arr_value+1) * (phase_shift_duty_cycle*1.0/100) - 1);
;;;128    //	TIM_SetCompare2(TIM1,TIM1_CH2_Pulse);
;;;129    	
;;;130    	uint32_t TIM8_CH1_Pulse=0;  //用于存放计算移相后CCR2的数值
000008  2600              MOVS     r6,#0
;;;131    	arr_value = TIM8 -> ARR;
00000a  481b              LDR      r0,|L2.120|
00000c  6800              LDR      r0,[r0,#0]
00000e  b285              UXTH     r5,r0
;;;132    	
;;;133    	TIM8_CH1_Pulse = (uint32_t) (((arr_value+1) * ((1000 - phase_shift_duty_cycle)*1.0/1000) - 1) );
000010  f5c4707a          RSB      r0,r4,#0x3e8
000014  f7fffffe          BL       __aeabi_i2d
000018  ec410b1d          VMOV     d13,r0,r1
00001c  ed9f0b17          VLDR     d0,|L2.124|
000020  ec532b10          VMOV     r2,r3,d0
000024  f7fffffe          BL       __aeabi_dmul
000028  ec410b1c          VMOV     d12,r0,r1
00002c  ed9f0b15          VLDR     d0,|L2.132|
000030  ec532b10          VMOV     r2,r3,d0
000034  f7fffffe          BL       __aeabi_ddiv
000038  ec410b1a          VMOV     d10,r0,r1
00003c  1c68              ADDS     r0,r5,#1
00003e  f7fffffe          BL       __aeabi_i2d
000042  ec410b1b          VMOV     d11,r0,r1
000046  ec532b1a          VMOV     r2,r3,d10
00004a  f7fffffe          BL       __aeabi_dmul
00004e  ec410b19          VMOV     d9,r0,r1
000052  ed9f0b0a          VLDR     d0,|L2.124|
000056  ec532b10          VMOV     r2,r3,d0
00005a  f7fffffe          BL       __aeabi_dsub
00005e  ec410b18          VMOV     d8,r0,r1
000062  f7fffffe          BL       __aeabi_d2uiz
000066  4606              MOV      r6,r0
;;;134    	TIM_SetCompare1(TIM8,TIM8_CH1_Pulse);
000068  4631              MOV      r1,r6
00006a  4803              LDR      r0,|L2.120|
00006c  382c              SUBS     r0,r0,#0x2c
00006e  f7fffffe          BL       TIM_SetCompare1
;;;135    
;;;136    }
000072  ecbd8b0c          VPOP     {d8-d13}
000076  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L2.120|
                          DCD      0x4001042c
                  |L2.124|
00007c  00000000          DCFD     0x3ff0000000000000 ; 1
000080  3ff00000
                  |L2.132|
000084  00000000          DCFD     0x408f400000000000 ; 1000
000088  408f4000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\phase_shift\\bsp_phase_shift.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_phase_shift_c_7b37e4c8____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_phase_shift_c_7b37e4c8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_phase_shift_c_7b37e4c8____REVSH|
#line 144
|__asm___17_bsp_phase_shift_c_7b37e4c8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_phase_shift_c_7b37e4c8____RRX|
#line 300
|__asm___17_bsp_phase_shift_c_7b37e4c8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
