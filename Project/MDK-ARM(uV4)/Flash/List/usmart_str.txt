; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usmart_str.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usmart_str.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\USMART -I..\..\User\bsp_stm32f4xx\LCD -I..\..\User\bsp_stm32f4xx\phase_shift -I..\..\User\bsp_stm32f4xx\PWMInput -I..\..\User\bsp_stm32f4xx\ADC -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F427xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\usmart_str.crf ..\..\USMART\usmart_str.c]
                          THUMB

                          AREA ||i.usmart_get_aparm||, CODE, READONLY, ALIGN=1

                  usmart_get_aparm PROC
;;;300    //返回值:0,已经无参数了;其他,下一个参数的偏移量.
;;;301    u8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype)
000000  b5f0              PUSH     {r4-r7,lr}
;;;302    {
000002  4603              MOV      r3,r0
000004  4615              MOV      r5,r2
;;;303    	u8 i=0;
000006  2000              MOVS     r0,#0
;;;304    	u8 enout=0;
000008  2200              MOVS     r2,#0
;;;305    	u8 type=0;//默认是数字
00000a  2600              MOVS     r6,#0
;;;306    	u8 string=0; //标记str是否正在读
00000c  2400              MOVS     r4,#0
;;;307    	while(1)
00000e  e055              B        |L1.188|
                  |L1.16|
;;;308    	{		    
;;;309    		if(*str==','&& string==0)enout=1;			//暂缓立即退出,目的是寻找下一个参数的起始地址
000010  781f              LDRB     r7,[r3,#0]
000012  2f2c              CMP      r7,#0x2c
000014  d101              BNE      |L1.26|
000016  b904              CBNZ     r4,|L1.26|
000018  2201              MOVS     r2,#1
                  |L1.26|
;;;310    		if((*str==')'||*str=='\0')&&string==0)break;//立即退出标识符
00001a  781f              LDRB     r7,[r3,#0]
00001c  2f29              CMP      r7,#0x29
00001e  d001              BEQ      |L1.36|
000020  781f              LDRB     r7,[r3,#0]
000022  b90f              CBNZ     r7,|L1.40|
                  |L1.36|
000024  b904              CBNZ     r4,|L1.40|
000026  e04a              B        |L1.190|
                  |L1.40|
;;;311    		if(type==0)//默认是数字的
000028  2e00              CMP      r6,#0
00002a  d134              BNE      |L1.150|
;;;312    		{
;;;313    			if((*str>='0' && *str<='9')||(*str>='a' && *str<='f')||(*str>='A' && *str<='F')||*str=='X'||*str=='x')//数字串检测
00002c  781f              LDRB     r7,[r3,#0]
00002e  2f30              CMP      r7,#0x30
000030  db02              BLT      |L1.56|
000032  781f              LDRB     r7,[r3,#0]
000034  2f39              CMP      r7,#0x39
000036  dd11              BLE      |L1.92|
                  |L1.56|
000038  781f              LDRB     r7,[r3,#0]
00003a  2f61              CMP      r7,#0x61
00003c  db02              BLT      |L1.68|
00003e  781f              LDRB     r7,[r3,#0]
000040  2f66              CMP      r7,#0x66
000042  dd0b              BLE      |L1.92|
                  |L1.68|
000044  781f              LDRB     r7,[r3,#0]
000046  2f41              CMP      r7,#0x41
000048  db02              BLT      |L1.80|
00004a  781f              LDRB     r7,[r3,#0]
00004c  2f46              CMP      r7,#0x46
00004e  dd05              BLE      |L1.92|
                  |L1.80|
000050  781f              LDRB     r7,[r3,#0]
000052  2f58              CMP      r7,#0x58
000054  d002              BEQ      |L1.92|
000056  781f              LDRB     r7,[r3,#0]
000058  2f78              CMP      r7,#0x78
00005a  d10c              BNE      |L1.118|
                  |L1.92|
;;;314    			{
;;;315    				if(enout)break;					//找到了下一个参数,直接退出.
00005c  b102              CBZ      r2,|L1.96|
00005e  e02e              B        |L1.190|
                  |L1.96|
;;;316    				if(*str>='a')*fparm=*str-0X20;	//小写转换为大写
000060  781f              LDRB     r7,[r3,#0]
000062  2f61              CMP      r7,#0x61
000064  db03              BLT      |L1.110|
000066  781f              LDRB     r7,[r3,#0]
000068  3f20              SUBS     r7,r7,#0x20
00006a  700f              STRB     r7,[r1,#0]
00006c  e001              B        |L1.114|
                  |L1.110|
;;;317    				else *fparm=*str;		   		//小写或者数字保持不变
00006e  781f              LDRB     r7,[r3,#0]
000070  700f              STRB     r7,[r1,#0]
                  |L1.114|
;;;318    				fparm++;
000072  1c49              ADDS     r1,r1,#1
000074  e01f              B        |L1.182|
                  |L1.118|
;;;319    			}else if(*str=='"')//找到字符串的开始标志
000076  781f              LDRB     r7,[r3,#0]
000078  2f22              CMP      r7,#0x22
00007a  d104              BNE      |L1.134|
;;;320    			{
;;;321    				if(enout)break;//找到,后才找到",认为结束了.
00007c  b102              CBZ      r2,|L1.128|
00007e  e01e              B        |L1.190|
                  |L1.128|
;;;322    				type=1;
000080  2601              MOVS     r6,#1
;;;323    				string=1;//登记STRING 正在读了
000082  2401              MOVS     r4,#1
000084  e017              B        |L1.182|
                  |L1.134|
;;;324    			}else if(*str!=' '&&*str!=',')//发现非法字符,参数错误
000086  781f              LDRB     r7,[r3,#0]
000088  2f20              CMP      r7,#0x20
00008a  d014              BEQ      |L1.182|
00008c  781f              LDRB     r7,[r3,#0]
00008e  2f2c              CMP      r7,#0x2c
000090  d011              BEQ      |L1.182|
;;;325    			{
;;;326    				type=0XFF;
000092  26ff              MOVS     r6,#0xff
;;;327    				break;
000094  e013              B        |L1.190|
                  |L1.150|
;;;328    			}
;;;329    		}else//string类
;;;330    		{ 
;;;331    			if(*str=='"')string=0;
000096  781f              LDRB     r7,[r3,#0]
000098  2f22              CMP      r7,#0x22
00009a  d100              BNE      |L1.158|
00009c  2400              MOVS     r4,#0
                  |L1.158|
;;;332    			if(enout)break;			//找到了下一个参数,直接退出.
00009e  b102              CBZ      r2,|L1.162|
0000a0  e00d              B        |L1.190|
                  |L1.162|
;;;333    			if(string)				//字符串正在读
0000a2  b144              CBZ      r4,|L1.182|
;;;334    			{	
;;;335    				if(*str=='\\')		//遇到转义符(不复制转义符)
0000a4  781f              LDRB     r7,[r3,#0]
0000a6  2f5c              CMP      r7,#0x5c
0000a8  d102              BNE      |L1.176|
;;;336    				{ 
;;;337    					str++;			//偏移到转义符后面的字符,不管什么字符,直接COPY
0000aa  1c5b              ADDS     r3,r3,#1
;;;338    					i++;
0000ac  1c47              ADDS     r7,r0,#1
0000ae  b2f8              UXTB     r0,r7
                  |L1.176|
;;;339    				}					
;;;340    				*fparm=*str;		//小写或者数字保持不变
0000b0  781f              LDRB     r7,[r3,#0]
0000b2  700f              STRB     r7,[r1,#0]
;;;341    				fparm++;
0000b4  1c49              ADDS     r1,r1,#1
                  |L1.182|
;;;342    			}	
;;;343    		}
;;;344    		i++;//偏移量增加
0000b6  1c47              ADDS     r7,r0,#1
0000b8  b2f8              UXTB     r0,r7
;;;345    		str++;
0000ba  1c5b              ADDS     r3,r3,#1
                  |L1.188|
0000bc  e7a8              B        |L1.16|
                  |L1.190|
0000be  bf00              NOP                            ;310
;;;346    	}
;;;347    	*fparm='\0';	//加入结束符
0000c0  2700              MOVS     r7,#0
0000c2  700f              STRB     r7,[r1,#0]
;;;348    	*ptype=type;	//返回参数类型
0000c4  702e              STRB     r6,[r5,#0]
;;;349    	return i;		//返回参数长度
;;;350    }
0000c6  bdf0              POP      {r4-r7,pc}
;;;351    //得到指定参数的起始地址
                          ENDP


                          AREA ||i.usmart_get_cmdname||, CODE, READONLY, ALIGN=1

                  usmart_get_cmdname PROC
;;;163    //返回值:0,成功;其他,失败.	  
;;;164    u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen)
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166    	*nlen=0;
000004  2000              MOVS     r0,#0
000006  7010              STRB     r0,[r2,#0]
;;;167     	while(*str!=' '&&*str!='\0') //找到空格或者结束符则认为结束了
000008  e00b              B        |L2.34|
                  |L2.10|
;;;168    	{
;;;169    		*cmdname=*str;
00000a  7820              LDRB     r0,[r4,#0]
00000c  7008              STRB     r0,[r1,#0]
;;;170    		str++;
00000e  1c64              ADDS     r4,r4,#1
;;;171    		cmdname++;
000010  1c49              ADDS     r1,r1,#1
;;;172    		(*nlen)++;//统计命令长度
000012  7810              LDRB     r0,[r2,#0]
000014  1c40              ADDS     r0,r0,#1
000016  7010              STRB     r0,[r2,#0]
;;;173    		if(*nlen>=maxlen)return 1;//错误的指令
000018  7810              LDRB     r0,[r2,#0]
00001a  4298              CMP      r0,r3
00001c  db01              BLT      |L2.34|
00001e  2001              MOVS     r0,#1
                  |L2.32|
;;;174    	}
;;;175    	*cmdname='\0';//加入结束符
;;;176    	return 0;//正常返回
;;;177    }
000020  bd10              POP      {r4,pc}
                  |L2.34|
000022  7820              LDRB     r0,[r4,#0]            ;167
000024  2820              CMP      r0,#0x20              ;167
000026  d002              BEQ      |L2.46|
000028  7820              LDRB     r0,[r4,#0]            ;167
00002a  2800              CMP      r0,#0                 ;167
00002c  d1ed              BNE      |L2.10|
                  |L2.46|
00002e  2000              MOVS     r0,#0                 ;175
000030  7008              STRB     r0,[r1,#0]            ;175
000032  bf00              NOP                            ;176
000034  e7f4              B        |L2.32|
;;;178    //获取下一个字符（当中间有很多空格的时候，此函数直接忽略空格，找到空格之后的第一个字符）
                          ENDP


                          AREA ||i.usmart_get_fname||, CODE, READONLY, ALIGN=2

                  usmart_get_fname PROC
;;;192    //返回值:0,成功;其他,错误代码.
;;;193    u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;194    {
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
;;;195    	u8 res;
;;;196    	u8 fover=0;	  //括号深度
00000a  2700              MOVS     r7,#0
;;;197    	u8 *strtemp;
;;;198    	u8 offset=0;  
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
;;;199    	u8 parmnum=0;
000010  9003              STR      r0,[sp,#0xc]
;;;200    	u8 temp=1;
000012  2001              MOVS     r0,#1
000014  9002              STR      r0,[sp,#8]
;;;201    	u8 fpname[6];//void+X+'/0'
;;;202    	u8 fplcnt=0; //第一个参数的长度计数器
000016  f04f0b00          MOV      r11,#0
;;;203    	u8 pcnt=0;	 //参数计数器
00001a  2500              MOVS     r5,#0
;;;204    	u8 nchar;
;;;205    	//判断函数是否有返回值
;;;206    	strtemp=str;
00001c  4644              MOV      r4,r8
;;;207    	while(*strtemp!='\0')//没有结束
00001e  e01d              B        |L3.92|
                  |L3.32|
;;;208    	{
;;;209    		if(*strtemp!=' '&&(pcnt&0X7F)<5)//最多记录5个字符
000020  7820              LDRB     r0,[r4,#0]
000022  2820              CMP      r0,#0x20
000024  d016              BEQ      |L3.84|
000026  f005007f          AND      r0,r5,#0x7f
00002a  2805              CMP      r0,#5
00002c  da12              BGE      |L3.84|
;;;210    		{	
;;;211    			if(pcnt==0)pcnt|=0X80;//置位最高位,标记开始接收返回值类型
00002e  b90d              CBNZ     r5,|L3.52|
000030  f0450580          ORR      r5,r5,#0x80
                  |L3.52|
;;;212    			if(((pcnt&0x7f)==4)&&(*strtemp!='*'))break;//最后一个字符,必须是*
000034  f005007f          AND      r0,r5,#0x7f
000038  2804              CMP      r0,#4
00003a  d103              BNE      |L3.68|
00003c  7820              LDRB     r0,[r4,#0]
00003e  282a              CMP      r0,#0x2a
000040  d000              BEQ      |L3.68|
000042  e00e              B        |L3.98|
                  |L3.68|
;;;213    			fpname[pcnt&0x7f]=*strtemp;//记录函数的返回值类型
000044  7820              LDRB     r0,[r4,#0]
000046  f005017f          AND      r1,r5,#0x7f
00004a  f80d0001          STRB     r0,[sp,r1]
;;;214    			pcnt++;
00004e  1c68              ADDS     r0,r5,#1
000050  b2c5              UXTB     r5,r0
000052  e002              B        |L3.90|
                  |L3.84|
;;;215    		}else if(pcnt==0X85)break;
000054  2d85              CMP      r5,#0x85
000056  d100              BNE      |L3.90|
000058  e003              B        |L3.98|
                  |L3.90|
;;;216    		strtemp++; 
00005a  1c64              ADDS     r4,r4,#1
                  |L3.92|
00005c  7820              LDRB     r0,[r4,#0]            ;207
00005e  2800              CMP      r0,#0                 ;207
000060  d1de              BNE      |L3.32|
                  |L3.98|
000062  bf00              NOP                            ;212
;;;217    	} 
;;;218    	if(pcnt)//接收完了
000064  b18d              CBZ      r5,|L3.138|
;;;219    	{
;;;220    		fpname[pcnt&0x7f]='\0';//加入结束符
000066  2000              MOVS     r0,#0
000068  f005017f          AND      r1,r5,#0x7f
00006c  f80d0001          STRB     r0,[sp,r1]
;;;221    		if(usmart_strcmp(fpname,"void")==0)*rval=0;//不需要返回值
000070  a151              ADR      r1,|L3.440|
000072  4668              MOV      r0,sp
000074  f7fffffe          BL       usmart_strcmp
000078  b918              CBNZ     r0,|L3.130|
00007a  2100              MOVS     r1,#0
00007c  9808              LDR      r0,[sp,#0x20]
00007e  7001              STRB     r1,[r0,#0]
000080  e002              B        |L3.136|
                  |L3.130|
;;;222    		else *rval=1;							   //需要返回值
000082  2101              MOVS     r1,#1
000084  9808              LDR      r0,[sp,#0x20]
000086  7001              STRB     r1,[r0,#0]
                  |L3.136|
;;;223    		pcnt=0;
000088  2500              MOVS     r5,#0
                  |L3.138|
;;;224    	} 
;;;225    	res=0;
00008a  f04f0a00          MOV      r10,#0
;;;226    	strtemp=str;
00008e  4644              MOV      r4,r8
;;;227    	while(*strtemp!='('&&*strtemp!='\0') //此代码找到函数名的真正起始位置
000090  e014              B        |L3.188|
                  |L3.146|
;;;228    	{  
;;;229    		strtemp++;
000092  1c64              ADDS     r4,r4,#1
;;;230    		res++;
000094  f10a0001          ADD      r0,r10,#1
000098  f0000aff          AND      r10,r0,#0xff
;;;231    		if(*strtemp==' '||*strtemp=='*')
00009c  7820              LDRB     r0,[r4,#0]
00009e  2820              CMP      r0,#0x20
0000a0  d002              BEQ      |L3.168|
0000a2  7820              LDRB     r0,[r4,#0]
0000a4  282a              CMP      r0,#0x2a
0000a6  d109              BNE      |L3.188|
                  |L3.168|
;;;232    		{
;;;233    			nchar=usmart_search_nextc(strtemp);		//获取下一个字符
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       usmart_search_nextc
0000ae  4606              MOV      r6,r0
;;;234    			if(nchar!='('&&nchar!='*')offset=res;	//跳过空格和*号
0000b0  2e28              CMP      r6,#0x28
0000b2  d003              BEQ      |L3.188|
0000b4  2e2a              CMP      r6,#0x2a
0000b6  d001              BEQ      |L3.188|
0000b8  f8cda010          STR      r10,[sp,#0x10]
                  |L3.188|
0000bc  7820              LDRB     r0,[r4,#0]            ;227
0000be  2828              CMP      r0,#0x28              ;227
0000c0  d002              BEQ      |L3.200|
0000c2  7820              LDRB     r0,[r4,#0]            ;227
0000c4  2800              CMP      r0,#0                 ;227
0000c6  d1e4              BNE      |L3.146|
                  |L3.200|
;;;235    		}
;;;236    	}	 
;;;237    	strtemp=str;
0000c8  4644              MOV      r4,r8
;;;238    	if(offset)strtemp+=offset+1;//跳到函数名开始的地方	   
0000ca  9804              LDR      r0,[sp,#0x10]
0000cc  b110              CBZ      r0,|L3.212|
0000ce  9804              LDR      r0,[sp,#0x10]
0000d0  1c40              ADDS     r0,r0,#1
0000d2  4404              ADD      r4,r4,r0
                  |L3.212|
;;;239    	res=0;
0000d4  f04f0a00          MOV      r10,#0
;;;240    	nchar=0;//是否正在字符串里面的标志,0，不在字符串;1，在字符串;
0000d8  2600              MOVS     r6,#0
;;;241    	while(1)
0000da  e054              B        |L3.390|
                  |L3.220|
;;;242    	{
;;;243    		if(*strtemp==0)
0000dc  7820              LDRB     r0,[r4,#0]
0000de  b910              CBNZ     r0,|L3.230|
;;;244    		{
;;;245    			res=USMART_FUNCERR;//函数错误
0000e0  f04f0a01          MOV      r10,#1
;;;246    			break;
0000e4  e050              B        |L3.392|
                  |L3.230|
;;;247    		}else if(*strtemp=='('&&nchar==0)fover++;//括号深度增加一级	 
0000e6  7820              LDRB     r0,[r4,#0]
0000e8  2828              CMP      r0,#0x28
0000ea  d103              BNE      |L3.244|
0000ec  b916              CBNZ     r6,|L3.244|
0000ee  1c78              ADDS     r0,r7,#1
0000f0  b2c7              UXTB     r7,r0
0000f2  e013              B        |L3.284|
                  |L3.244|
;;;248    		else if(*strtemp==')'&&nchar==0)
0000f4  7820              LDRB     r0,[r4,#0]
0000f6  2829              CMP      r0,#0x29
0000f8  d108              BNE      |L3.268|
0000fa  b93e              CBNZ     r6,|L3.268|
;;;249    		{
;;;250    			if(fover)fover--;
0000fc  b117              CBZ      r7,|L3.260|
0000fe  1e78              SUBS     r0,r7,#1
000100  b2c7              UXTB     r7,r0
000102  e001              B        |L3.264|
                  |L3.260|
;;;251    			else res=USMART_FUNCERR;//错误结束,没收到'('
000104  f04f0a01          MOV      r10,#1
                  |L3.264|
;;;252    			if(fover==0)break;//到末尾了,退出	    
000108  b947              CBNZ     r7,|L3.284|
00010a  e03d              B        |L3.392|
                  |L3.268|
;;;253    		}else if(*strtemp=='"')nchar=!nchar;
00010c  7820              LDRB     r0,[r4,#0]
00010e  2822              CMP      r0,#0x22
000110  d104              BNE      |L3.284|
000112  b90e              CBNZ     r6,|L3.280|
000114  2001              MOVS     r0,#1
000116  e000              B        |L3.282|
                  |L3.280|
000118  2000              MOVS     r0,#0
                  |L3.282|
00011a  4606              MOV      r6,r0
                  |L3.284|
;;;254    
;;;255    		if(fover==0)//函数名还没接收完
00011c  b947              CBNZ     r7,|L3.304|
;;;256    		{
;;;257    			if(*strtemp!=' ')//空格不属于函数名
00011e  7820              LDRB     r0,[r4,#0]
000120  2820              CMP      r0,#0x20
000122  d02f              BEQ      |L3.388|
;;;258    			{
;;;259    				*fname=*strtemp;//得到函数名
000124  7820              LDRB     r0,[r4,#0]
000126  f8890000          STRB     r0,[r9,#0]
;;;260    				fname++;
00012a  f1090901          ADD      r9,r9,#1
00012e  e029              B        |L3.388|
                  |L3.304|
;;;261    			}
;;;262    		}else //已经接受完了函数名了.
;;;263    		{
;;;264    			if(*strtemp==',')
000130  7820              LDRB     r0,[r4,#0]
000132  282c              CMP      r0,#0x2c
000134  d104              BNE      |L3.320|
;;;265    			{
;;;266    				temp=1;		//使能增加一个参数
000136  2001              MOVS     r0,#1
000138  9002              STR      r0,[sp,#8]
;;;267    				pcnt++;	
00013a  1c68              ADDS     r0,r5,#1
00013c  b2c5              UXTB     r5,r0
00013e  e014              B        |L3.362|
                  |L3.320|
;;;268    			}else if(*strtemp!=' '&&*strtemp!='(')
000140  7820              LDRB     r0,[r4,#0]
000142  2820              CMP      r0,#0x20
000144  d011              BEQ      |L3.362|
000146  7820              LDRB     r0,[r4,#0]
000148  2828              CMP      r0,#0x28
00014a  d00e              BEQ      |L3.362|
;;;269    			{
;;;270    				if(pcnt==0&&fplcnt<5)		//当第一个参数来时,为了避免统计void类型的参数,必须做判断.
00014c  b94d              CBNZ     r5,|L3.354|
00014e  f1bb0f05          CMP      r11,#5
000152  da06              BGE      |L3.354|
;;;271    				{
;;;272    					fpname[fplcnt]=*strtemp;//记录参数特征.
000154  7820              LDRB     r0,[r4,#0]
000156  f80d000b          STRB     r0,[sp,r11]
;;;273    					fplcnt++;
00015a  f10b0001          ADD      r0,r11,#1
00015e  f0000bff          AND      r11,r0,#0xff
                  |L3.354|
;;;274    				}
;;;275    				temp++;	//得到有效参数(非空格)
000162  9802              LDR      r0,[sp,#8]
000164  1c40              ADDS     r0,r0,#1
000166  b2c0              UXTB     r0,r0
000168  9002              STR      r0,[sp,#8]
                  |L3.362|
;;;276    			}
;;;277    			if(fover==1&&temp==2)
00016a  2f01              CMP      r7,#1
00016c  d10a              BNE      |L3.388|
00016e  9802              LDR      r0,[sp,#8]
000170  2802              CMP      r0,#2
000172  d107              BNE      |L3.388|
;;;278    			{
;;;279    				temp++;		//防止重复增加
000174  9802              LDR      r0,[sp,#8]
000176  1c40              ADDS     r0,r0,#1
000178  b2c0              UXTB     r0,r0
00017a  9002              STR      r0,[sp,#8]
;;;280    				parmnum++; 	//参数增加一个
00017c  9803              LDR      r0,[sp,#0xc]
00017e  1c40              ADDS     r0,r0,#1
000180  b2c0              UXTB     r0,r0
000182  9003              STR      r0,[sp,#0xc]
                  |L3.388|
;;;281    			}
;;;282    		}
;;;283    		strtemp++; 			
000184  1c64              ADDS     r4,r4,#1
                  |L3.390|
000186  e7a9              B        |L3.220|
                  |L3.392|
000188  bf00              NOP                            ;246
;;;284    	}   
;;;285    	if(parmnum==1)//只有1个参数.
00018a  9803              LDR      r0,[sp,#0xc]
00018c  2801              CMP      r0,#1
00018e  d109              BNE      |L3.420|
;;;286    	{
;;;287    		fpname[fplcnt]='\0';//加入结束符
000190  2000              MOVS     r0,#0
000192  f80d000b          STRB     r0,[sp,r11]
;;;288    		if(usmart_strcmp(fpname,"void")==0)parmnum=0;//参数为void,表示没有参数.
000196  a108              ADR      r1,|L3.440|
000198  4668              MOV      r0,sp
00019a  f7fffffe          BL       usmart_strcmp
00019e  b908              CBNZ     r0,|L3.420|
0001a0  2000              MOVS     r0,#0
0001a2  9003              STR      r0,[sp,#0xc]
                  |L3.420|
;;;289    	}
;;;290    	*pnum=parmnum;	//记录参数个数
0001a4  9907              LDR      r1,[sp,#0x1c]
0001a6  9803              LDR      r0,[sp,#0xc]
0001a8  7008              STRB     r0,[r1,#0]
;;;291    	*fname='\0';	//加入结束符
0001aa  2000              MOVS     r0,#0
0001ac  f8890000          STRB     r0,[r9,#0]
;;;292    	return res;		//返回执行结果
0001b0  4650              MOV      r0,r10
;;;293    }
0001b2  b009              ADD      sp,sp,#0x24
0001b4  e8bd8ff0          POP      {r4-r11,pc}
;;;294    
                          ENDP

                  |L3.440|
0001b8  766f6964          DCB      "void",0
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.usmart_get_fparam||, CODE, READONLY, ALIGN=2

                  usmart_get_fparam PROC
;;;364    //返回值:0,成功;其他,错误代码.
;;;365    u8 usmart_get_fparam(u8*str,u8 *parn)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;366    {	
000004  b0b5              SUB      sp,sp,#0xd4
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;367    	u8 i,type;  
;;;368    	u32 res;
;;;369    	u8 n=0;
00000a  2400              MOVS     r4,#0
;;;370    	u8 len;
;;;371    	u8 tstr[PARM_LEN+1];//字节长度的缓存,最多可以存放PARM_LEN个字符的字符串
;;;372    	for(i=0;i<MAX_PARM;i++)usmart_dev.plentbl[i]=0;//清空参数长度表
00000c  2600              MOVS     r6,#0
00000e  e004              B        |L4.26|
                  |L4.16|
000010  2100              MOVS     r1,#0
000012  483d              LDR      r0,|L4.264|
000014  5581              STRB     r1,[r0,r6]
000016  1c70              ADDS     r0,r6,#1
000018  b2c6              UXTB     r6,r0
                  |L4.26|
00001a  2e0a              CMP      r6,#0xa
00001c  dbf8              BLT      |L4.16|
;;;373    	while(*str!='(')//偏移到参数开始的地方
00001e  e006              B        |L4.46|
                  |L4.32|
;;;374    	{
;;;375    		str++;											    
000020  1c6d              ADDS     r5,r5,#1
;;;376    		if(*str=='\0')return USMART_FUNCERR;//遇到结束符了
000022  7828              LDRB     r0,[r5,#0]
000024  b918              CBNZ     r0,|L4.46|
000026  2001              MOVS     r0,#1
                  |L4.40|
;;;377    	}
;;;378    	str++;//偏移到"("之后的第一个字节
;;;379    	while(1)
;;;380    	{
;;;381    		i=usmart_get_aparm(str,tstr,&type);	//得到第一个参数  
;;;382    		str+=i;								//偏移
;;;383    		switch(type)
;;;384    		{
;;;385    			case 0:	//数字
;;;386    				if(tstr[0]!='\0')				//接收到的参数有效
;;;387    				{					    
;;;388    					i=usmart_str2num(tstr,&res);	//记录该参数	 
;;;389    					if(i)return USMART_PARMERR;		//参数错误.
;;;390    					*(u32*)(usmart_dev.parm+usmart_get_parmpos(n))=res;//记录转换成功的结果.
;;;391    					usmart_dev.parmtype&=~(1<<n);	//标记数字
;;;392    					usmart_dev.plentbl[n]=4;		//该参数的长度为4  
;;;393    					n++;							//参数增加  
;;;394    					if(n>MAX_PARM)return USMART_PARMOVER;//参数太多
;;;395    				}
;;;396    				break;
;;;397    			case 1://字符串	 	
;;;398    				len=usmart_strlen(tstr)+1;	//包含了结束符'\0'
;;;399    				usmart_strcopy(tstr,&usmart_dev.parm[usmart_get_parmpos(n)]);//拷贝tstr数据到usmart_dev.parm[n]
;;;400    				usmart_dev.parmtype|=1<<n;	//标记字符串 
;;;401    				usmart_dev.plentbl[n]=len;	//该参数的长度为len  
;;;402    				n++;
;;;403    				if(n>MAX_PARM)return USMART_PARMOVER;//参数太多
;;;404    				break;
;;;405    			case 0XFF://错误
;;;406    				return USMART_PARMERR;//参数错误	  
;;;407    		}
;;;408    		if(*str==')'||*str=='\0')break;//查到结束标志了.
;;;409    	}
;;;410    	*parn=n;	//记录参数的个数
;;;411    	return USMART_OK;//正确得到了参数
;;;412    }
000028  b035              ADD      sp,sp,#0xd4
00002a  e8bd83f0          POP      {r4-r9,pc}
                  |L4.46|
00002e  7828              LDRB     r0,[r5,#0]            ;373
000030  2828              CMP      r0,#0x28              ;373
000032  d1f5              BNE      |L4.32|
000034  1c6d              ADDS     r5,r5,#1              ;378
000036  e061              B        |L4.252|
                  |L4.56|
000038  aa34              ADD      r2,sp,#0xd0           ;381
00003a  4669              MOV      r1,sp                 ;381
00003c  4628              MOV      r0,r5                 ;381
00003e  f7fffffe          BL       usmart_get_aparm
000042  4606              MOV      r6,r0                 ;381
000044  4435              ADD      r5,r5,r6              ;382
000046  f89d00d0          LDRB     r0,[sp,#0xd0]         ;383
00004a  b120              CBZ      r0,|L4.86|
00004c  2801              CMP      r0,#1                 ;383
00004e  d027              BEQ      |L4.160|
000050  28ff              CMP      r0,#0xff              ;383
000052  d14c              BNE      |L4.238|
000054  e049              B        |L4.234|
                  |L4.86|
000056  f89d0000          LDRB     r0,[sp,#0]            ;386
00005a  b300              CBZ      r0,|L4.158|
00005c  a933              ADD      r1,sp,#0xcc           ;388
00005e  4668              MOV      r0,sp                 ;388
000060  f7fffffe          BL       usmart_str2num
000064  4606              MOV      r6,r0                 ;388
000066  b10e              CBZ      r6,|L4.108|
000068  2002              MOVS     r0,#2                 ;389
00006a  e7dd              B        |L4.40|
                  |L4.108|
00006c  4620              MOV      r0,r4                 ;390
00006e  f7fffffe          BL       usmart_get_parmpos
000072  4925              LDR      r1,|L4.264|
000074  310a              ADDS     r1,r1,#0xa            ;390
000076  9a33              LDR      r2,[sp,#0xcc]         ;390
000078  500a              STR      r2,[r1,r0]            ;390
00007a  f1a10024          SUB      r0,r1,#0x24           ;391
00007e  8b00              LDRH     r0,[r0,#0x18]         ;391  ; usmart_dev
000080  2101              MOVS     r1,#1                 ;391
000082  40a1              LSLS     r1,r1,r4              ;391
000084  4388              BICS     r0,r0,r1              ;391
000086  4920              LDR      r1,|L4.264|
000088  391a              SUBS     r1,r1,#0x1a           ;391
00008a  8308              STRH     r0,[r1,#0x18]         ;391
00008c  2104              MOVS     r1,#4                 ;392
00008e  481e              LDR      r0,|L4.264|
000090  5501              STRB     r1,[r0,r4]            ;392
000092  1c60              ADDS     r0,r4,#1              ;393
000094  b2c4              UXTB     r4,r0                 ;393
000096  2c0a              CMP      r4,#0xa               ;394
000098  dd01              BLE      |L4.158|
00009a  2003              MOVS     r0,#3                 ;394
00009c  e7c4              B        |L4.40|
                  |L4.158|
00009e  e026              B        |L4.238|
                  |L4.160|
0000a0  4668              MOV      r0,sp                 ;398
0000a2  f7fffffe          BL       usmart_strlen
0000a6  1c40              ADDS     r0,r0,#1              ;398
0000a8  f00008ff          AND      r8,r0,#0xff           ;398
0000ac  4620              MOV      r0,r4                 ;399
0000ae  f7fffffe          BL       usmart_get_parmpos
0000b2  4915              LDR      r1,|L4.264|
0000b4  310a              ADDS     r1,r1,#0xa            ;399
0000b6  eb000901          ADD      r9,r0,r1              ;399
0000ba  4649              MOV      r1,r9                 ;399
0000bc  4668              MOV      r0,sp                 ;399
0000be  f7fffffe          BL       usmart_strcopy
0000c2  4811              LDR      r0,|L4.264|
0000c4  381a              SUBS     r0,r0,#0x1a           ;400
0000c6  8b01              LDRH     r1,[r0,#0x18]         ;400  ; usmart_dev
0000c8  2001              MOVS     r0,#1                 ;400
0000ca  40a0              LSLS     r0,r0,r4              ;400
0000cc  4301              ORRS     r1,r1,r0              ;400
0000ce  b288              UXTH     r0,r1                 ;400
0000d0  490d              LDR      r1,|L4.264|
0000d2  391a              SUBS     r1,r1,#0x1a           ;400
0000d4  8308              STRH     r0,[r1,#0x18]         ;400
0000d6  480c              LDR      r0,|L4.264|
0000d8  f8008004          STRB     r8,[r0,r4]            ;401
0000dc  1c60              ADDS     r0,r4,#1              ;402
0000de  b2c4              UXTB     r4,r0                 ;402
0000e0  2c0a              CMP      r4,#0xa               ;403
0000e2  dd01              BLE      |L4.232|
0000e4  2003              MOVS     r0,#3                 ;403
0000e6  e79f              B        |L4.40|
                  |L4.232|
0000e8  e001              B        |L4.238|
                  |L4.234|
0000ea  2002              MOVS     r0,#2                 ;406
0000ec  e79c              B        |L4.40|
                  |L4.238|
0000ee  bf00              NOP                            ;396
0000f0  7828              LDRB     r0,[r5,#0]            ;408
0000f2  2829              CMP      r0,#0x29              ;408
0000f4  d001              BEQ      |L4.250|
0000f6  7828              LDRB     r0,[r5,#0]            ;408
0000f8  b900              CBNZ     r0,|L4.252|
                  |L4.250|
0000fa  e000              B        |L4.254|
                  |L4.252|
0000fc  e79c              B        |L4.56|
                  |L4.254|
0000fe  bf00              NOP                            ;408
000100  703c              STRB     r4,[r7,#0]            ;410
000102  2000              MOVS     r0,#0                 ;411
000104  e790              B        |L4.40|
;;;413    
                          ENDP

000106  0000              DCW      0x0000
                  |L4.264|
                          DCD      usmart_dev+0x1a

                          AREA ||i.usmart_get_parmpos||, CODE, READONLY, ALIGN=2

                  usmart_get_parmpos PROC
;;;353    //返回值:该参数的起始地址
;;;354    u8 usmart_get_parmpos(u8 num)
000000  4602              MOV      r2,r0
;;;355    {
;;;356    	u8 temp=0;
000002  2000              MOVS     r0,#0
;;;357    	u8 i;
;;;358    	for(i=0;i<num;i++)temp+=usmart_dev.plentbl[i];
000004  2100              MOVS     r1,#0
000006  e005              B        |L5.20|
                  |L5.8|
000008  4b04              LDR      r3,|L5.28|
00000a  5c5b              LDRB     r3,[r3,r1]
00000c  4403              ADD      r3,r3,r0
00000e  b2d8              UXTB     r0,r3
000010  1c4b              ADDS     r3,r1,#1
000012  b2d9              UXTB     r1,r3
                  |L5.20|
000014  4291              CMP      r1,r2
000016  dbf7              BLT      |L5.8|
;;;359    	return temp;
;;;360    }
000018  4770              BX       lr
;;;361    //从str中得到函数参数
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      usmart_dev+0x1a

                          AREA ||i.usmart_pow||, CODE, READONLY, ALIGN=1

                  usmart_pow PROC
;;;105    //返回值:m^n次方
;;;106    u32 usmart_pow(u8 m,u8 n)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4602              MOV      r2,r0
;;;108    	u32 result=1;	 
000004  2001              MOVS     r0,#1
;;;109    	while(n--)result*=m;    
000006  e000              B        |L6.10|
                  |L6.8|
000008  4350              MULS     r0,r2,r0
                  |L6.10|
00000a  1e0b              SUBS     r3,r1,#0
00000c  f1a10401          SUB      r4,r1,#1
000010  b2e1              UXTB     r1,r4
000012  d1f9              BNE      |L6.8|
;;;110    	return result;
;;;111    }	    
000014  bd10              POP      {r4,pc}
;;;112    //把字符串转为数字
                          ENDP


                          AREA ||i.usmart_search_nextc||, CODE, READONLY, ALIGN=1

                  usmart_search_nextc PROC
;;;180    //返回值:下一个字符
;;;181    u8 usmart_search_nextc(u8* str)
000000  4601              MOV      r1,r0
;;;182    {		   	 	
;;;183    	str++;
000002  1c49              ADDS     r1,r1,#1
;;;184    	while(*str==' '&&str!='\0')str++;
000004  e000              B        |L7.8|
                  |L7.6|
000006  1c49              ADDS     r1,r1,#1
                  |L7.8|
000008  7808              LDRB     r0,[r1,#0]
00000a  2820              CMP      r0,#0x20
00000c  d101              BNE      |L7.18|
00000e  2900              CMP      r1,#0
000010  d1f9              BNE      |L7.6|
                  |L7.18|
;;;185    	return *str;
000012  7808              LDRB     r0,[r1,#0]
;;;186    } 
000014  4770              BX       lr
;;;187    //从str中得到函数名
                          ENDP


                          AREA ||i.usmart_str2num||, CODE, READONLY, ALIGN=1

                  usmart_str2num PROC
;;;118    //1,数据格式错误.2,16进制位数为0.3,起始格式错误.4,十进制位数为0.
;;;119    u8 usmart_str2num(u8*str,u32 *res)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;120    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;121    	u32 t;
;;;122    	u8 bnum=0;	//数字的位数
000008  2500              MOVS     r5,#0
;;;123    	u8 *p;		  
;;;124    	u8 hexdec=10;//默认为十进制数据
00000a  f04f080a          MOV      r8,#0xa
;;;125    	p=str;
00000e  463c              MOV      r4,r7
;;;126    	*res=0;//清零.
000010  2000              MOVS     r0,#0
000012  6030              STR      r0,[r6,#0]
;;;127    	while(1)
000014  e01f              B        |L8.86|
                  |L8.22|
;;;128    	{
;;;129    		if((*p<='9'&&*p>='0')||(*p<='F'&&*p>='A')||(*p=='X'&&bnum==1))//参数合法
000016  7820              LDRB     r0,[r4,#0]
000018  2839              CMP      r0,#0x39
00001a  dc02              BGT      |L8.34|
00001c  7820              LDRB     r0,[r4,#0]
00001e  2830              CMP      r0,#0x30
000020  da0a              BGE      |L8.56|
                  |L8.34|
000022  7820              LDRB     r0,[r4,#0]
000024  2846              CMP      r0,#0x46
000026  dc02              BGT      |L8.46|
000028  7820              LDRB     r0,[r4,#0]
00002a  2841              CMP      r0,#0x41
00002c  da04              BGE      |L8.56|
                  |L8.46|
00002e  7820              LDRB     r0,[r4,#0]
000030  2858              CMP      r0,#0x58
000032  d109              BNE      |L8.72|
000034  2d01              CMP      r5,#1
000036  d107              BNE      |L8.72|
                  |L8.56|
;;;130    		{
;;;131    			if(*p>='A')hexdec=16;	//字符串中存在字母,为16进制格式.
000038  7820              LDRB     r0,[r4,#0]
00003a  2841              CMP      r0,#0x41
00003c  db01              BLT      |L8.66|
00003e  f04f0810          MOV      r8,#0x10
                  |L8.66|
;;;132    			bnum++;					//位数增加.
000042  1c68              ADDS     r0,r5,#1
000044  b2c5              UXTB     r5,r0
000046  e005              B        |L8.84|
                  |L8.72|
;;;133    		}else if(*p=='\0')break;	//碰到结束符,退出.
000048  7820              LDRB     r0,[r4,#0]
00004a  b900              CBNZ     r0,|L8.78|
00004c  e004              B        |L8.88|
                  |L8.78|
;;;134    		else return 1;				//不全是十进制或者16进制数据.
00004e  2001              MOVS     r0,#1
                  |L8.80|
;;;135    		p++; 
;;;136    	} 
;;;137    	p=str;			    //重新定位到字符串开始的地址.
;;;138    	if(hexdec==16)		//16进制数据
;;;139    	{
;;;140    		if(bnum<3)return 2;			//位数小于3，直接退出.因为0X就占了2个,如果0X后面不跟数据,则该数据非法.
;;;141    		if(*p=='0' && (*(p+1)=='X'))//必须以'0X'开头.
;;;142    		{
;;;143    			p+=2;	//偏移到数据起始地址.
;;;144    			bnum-=2;//减去偏移量	 
;;;145    		}else return 3;//起始头的格式不对
;;;146    	}else if(bnum==0)return 4;//位数为0，直接退出.	  
;;;147    	while(1)
;;;148    	{
;;;149    		if(bnum)bnum--;
;;;150    		if(*p<='9'&&*p>='0')t=*p-'0';	//得到数字的值
;;;151    		else t=*p-'A'+10;				//得到A~F对应的值	    
;;;152    		*res+=t*usmart_pow(hexdec,bnum);		   
;;;153    		p++;
;;;154    		if(*p=='\0')break;//数据都查完了.	
;;;155    	}
;;;156    	return 0;//成功转换
;;;157    }
000050  e8bd83f0          POP      {r4-r9,pc}
                  |L8.84|
000054  1c64              ADDS     r4,r4,#1              ;135
                  |L8.86|
000056  e7de              B        |L8.22|
                  |L8.88|
000058  bf00              NOP                            ;133
00005a  463c              MOV      r4,r7                 ;137
00005c  f1b80f10          CMP      r8,#0x10              ;138
000060  d10f              BNE      |L8.130|
000062  2d03              CMP      r5,#3                 ;140
000064  da01              BGE      |L8.106|
000066  2002              MOVS     r0,#2                 ;140
000068  e7f2              B        |L8.80|
                  |L8.106|
00006a  7820              LDRB     r0,[r4,#0]            ;141
00006c  2830              CMP      r0,#0x30              ;141
00006e  d106              BNE      |L8.126|
000070  7860              LDRB     r0,[r4,#1]            ;141
000072  2858              CMP      r0,#0x58              ;141
000074  d103              BNE      |L8.126|
000076  1ca4              ADDS     r4,r4,#2              ;143
000078  1ea8              SUBS     r0,r5,#2              ;144
00007a  b2c5              UXTB     r5,r0                 ;144
00007c  e004              B        |L8.136|
                  |L8.126|
00007e  2003              MOVS     r0,#3                 ;145
000080  e7e6              B        |L8.80|
                  |L8.130|
000082  b90d              CBNZ     r5,|L8.136|
000084  2004              MOVS     r0,#4                 ;146
000086  e7e3              B        |L8.80|
                  |L8.136|
000088  e01b              B        |L8.194|
                  |L8.138|
00008a  b10d              CBZ      r5,|L8.144|
00008c  1e68              SUBS     r0,r5,#1              ;149
00008e  b2c5              UXTB     r5,r0                 ;149
                  |L8.144|
000090  7820              LDRB     r0,[r4,#0]            ;150
000092  2839              CMP      r0,#0x39              ;150
000094  dc06              BGT      |L8.164|
000096  7820              LDRB     r0,[r4,#0]            ;150
000098  2830              CMP      r0,#0x30              ;150
00009a  db03              BLT      |L8.164|
00009c  7820              LDRB     r0,[r4,#0]            ;150
00009e  f1a00930          SUB      r9,r0,#0x30           ;150
0000a2  e002              B        |L8.170|
                  |L8.164|
0000a4  7820              LDRB     r0,[r4,#0]            ;151
0000a6  f1a00937          SUB      r9,r0,#0x37           ;151
                  |L8.170|
0000aa  4629              MOV      r1,r5                 ;152
0000ac  4640              MOV      r0,r8                 ;152
0000ae  f7fffffe          BL       usmart_pow
0000b2  6831              LDR      r1,[r6,#0]            ;152
0000b4  fb091000          MLA      r0,r9,r0,r1           ;152
0000b8  6030              STR      r0,[r6,#0]            ;152
0000ba  1c64              ADDS     r4,r4,#1              ;153
0000bc  7820              LDRB     r0,[r4,#0]            ;154
0000be  b900              CBNZ     r0,|L8.194|
0000c0  e000              B        |L8.196|
                  |L8.194|
0000c2  e7e2              B        |L8.138|
                  |L8.196|
0000c4  bf00              NOP                            ;154
0000c6  2000              MOVS     r0,#0                 ;156
0000c8  e7c2              B        |L8.80|
;;;158    //得到指令名
                          ENDP


                          AREA ||i.usmart_strcmp||, CODE, READONLY, ALIGN=1

                  usmart_strcmp PROC
;;;65     //返回值:0，相等;1，不相等;
;;;66     u8 usmart_strcmp(u8 *str1,u8 *str2)
000000  4602              MOV      r2,r0
;;;67     {
;;;68     	while(1)
000002  e00a              B        |L9.26|
                  |L9.4|
;;;69     	{
;;;70     		if(*str1!=*str2)return 1;//不相等
000004  7810              LDRB     r0,[r2,#0]
000006  780b              LDRB     r3,[r1,#0]
000008  4298              CMP      r0,r3
00000a  d001              BEQ      |L9.16|
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;71     		if(*str1=='\0')break;//对比完成了.
;;;72     		str1++;
;;;73     		str2++;
;;;74     	}
;;;75     	return 0;//两个字符串相等
;;;76     }
00000e  4770              BX       lr
                  |L9.16|
000010  7810              LDRB     r0,[r2,#0]            ;71
000012  b900              CBNZ     r0,|L9.22|
000014  e002              B        |L9.28|
                  |L9.22|
000016  1c52              ADDS     r2,r2,#1              ;72
000018  1c49              ADDS     r1,r1,#1              ;73
                  |L9.26|
00001a  e7f3              B        |L9.4|
                  |L9.28|
00001c  bf00              NOP                            ;71
00001e  2000              MOVS     r0,#0                 ;75
000020  e7f5              B        |L9.14|
;;;77     //把str1的内容copy到str2
                          ENDP


                          AREA ||i.usmart_strcopy||, CODE, READONLY, ALIGN=1

                  usmart_strcopy PROC
;;;79     //*str2:字符串2指针			   
;;;80     void usmart_strcopy(u8*str1,u8 *str2)
000000  e006              B        |L10.16|
                  |L10.2|
;;;81     {
;;;82     	while(1)
;;;83     	{										   
;;;84     		*str2=*str1;	//拷贝
000002  7802              LDRB     r2,[r0,#0]
000004  700a              STRB     r2,[r1,#0]
;;;85     		if(*str1=='\0')break;//拷贝完成了.
000006  7802              LDRB     r2,[r0,#0]
000008  b902              CBNZ     r2,|L10.12|
00000a  e002              B        |L10.18|
                  |L10.12|
;;;86     		str1++;
00000c  1c40              ADDS     r0,r0,#1
;;;87     		str2++;
00000e  1c49              ADDS     r1,r1,#1
                  |L10.16|
000010  e7f7              B        |L10.2|
                  |L10.18|
000012  bf00              NOP                            ;85
;;;88     	}
;;;89     }
000014  4770              BX       lr
;;;90     //得到字符串的长度(字节)
                          ENDP


                          AREA ||i.usmart_strlen||, CODE, READONLY, ALIGN=1

                  usmart_strlen PROC
;;;92     //返回值:字符串的长度		   
;;;93     u8 usmart_strlen(u8*str)
000000  4601              MOV      r1,r0
;;;94     {
;;;95     	u8 len=0;
000002  2000              MOVS     r0,#0
;;;96     	while(1)
000004  e005              B        |L11.18|
                  |L11.6|
;;;97     	{							 
;;;98     		if(*str=='\0')break;//拷贝完成了.
000006  780a              LDRB     r2,[r1,#0]
000008  b902              CBNZ     r2,|L11.12|
00000a  e003              B        |L11.20|
                  |L11.12|
;;;99     		len++;
00000c  1c42              ADDS     r2,r0,#1
00000e  b2d0              UXTB     r0,r2
;;;100    		str++;
000010  1c49              ADDS     r1,r1,#1
                  |L11.18|
000012  e7f8              B        |L11.6|
                  |L11.20|
000014  bf00              NOP                            ;98
;;;101    	}
;;;102    	return len;
;;;103    }
000016  4770              BX       lr
;;;104    //m^n函数
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\USMART\\usmart_str.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_usmart_str_c_f7d9c3df____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_usmart_str_c_f7d9c3df____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_usmart_str_c_f7d9c3df____REVSH|
#line 144
|__asm___12_usmart_str_c_f7d9c3df____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_usmart_str_c_f7d9c3df____RRX|
#line 300
|__asm___12_usmart_str_c_f7d9c3df____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
