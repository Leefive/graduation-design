; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\USMART -I..\..\User\bsp_stm32f4xx\LCD -I..\..\User\bsp_stm32f4xx\phase_shift -I..\..\User\bsp_stm32f4xx\PWMInput -I..\..\User\bsp_stm32f4xx\ADC -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F427xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp_stm32f4xx\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;98     */
;;;99     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;102    	{
;;;103    		#if UART1_FIFO_EN == 1
;;;104    			return &g_tUart1;
000004  480b              LDR      r0,|L1.52|
                  |L1.6|
;;;105    		#else
;;;106    			return 0;
;;;107    		#endif
;;;108    	}
;;;109    	else if (_ucPort == COM2)
;;;110    	{
;;;111    		#if UART2_FIFO_EN == 1
;;;112    			return &g_tUart2;
;;;113    		#else
;;;114    			return;
;;;115    		#endif
;;;116    	}
;;;117    	else if (_ucPort == COM3)
;;;118    	{
;;;119    		#if UART3_FIFO_EN == 1
;;;120    			return &g_tUart3;
;;;121    		#else
;;;122    			return 0;
;;;123    		#endif
;;;124    	}
;;;125    	else if (_ucPort == COM4)
;;;126    	{
;;;127    		#if UART4_FIFO_EN == 1
;;;128    			return &g_tUart4;
;;;129    		#else
;;;130    			return 0;
;;;131    		#endif
;;;132    	}
;;;133    	else if (_ucPort == COM5)
;;;134    	{
;;;135    		#if UART5_FIFO_EN == 1
;;;136    			return &g_tUart5;
;;;137    		#else
;;;138    			return 0;
;;;139    		#endif
;;;140    	}
;;;141    	else if (_ucPort == COM6)
;;;142    	{
;;;143    		#if UART6_FIFO_EN == 1
;;;144    			return &g_tUart6;
;;;145    		#else
;;;146    			return 0;
;;;147    		#endif
;;;148    	}
;;;149    	else
;;;150    	{
;;;151    		/* 不做任何处理 */
;;;152    		return 0;
;;;153    	}
;;;154    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;109
00000a  d101              BNE      |L1.16|
00000c  480a              LDR      r0,|L1.56|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;117
000012  d101              BNE      |L1.24|
000014  4809              LDR      r0,|L1.60|
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;125
00001a  d101              BNE      |L1.32|
00001c  2000              MOVS     r0,#0                 ;130
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;133
000022  d101              BNE      |L1.40|
000024  2000              MOVS     r0,#0                 ;138
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2905              CMP      r1,#5                 ;141
00002a  d101              BNE      |L1.48|
00002c  4804              LDR      r0,|L1.64|
00002e  e7ea              B        |L1.6|
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;152
000032  e7e8              B        |L1.6|
;;;155    
                          ENDP

                  |L1.52|
                          DCD      g_tUart1
                  |L1.56|
                          DCD      g_tUart2
                  |L1.60|
                          DCD      g_tUart3
                  |L1.64|
                          DCD      g_tUart6

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;909    */
;;;910    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;911    {
;;;912    	NVIC_InitTypeDef NVIC_InitStructure;
;;;913    
;;;914    	/* Configure the NVIC Preemption Priority Bits */
;;;915    	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;916    
;;;917    #if UART1_FIFO_EN == 1
;;;918    	/* 使能串口1中断 */
;;;919    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;920    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000008  2000              MOVS     r0,#0
00000a  f88d0002          STRB     r0,[sp,#2]
;;;921    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00000e  2001              MOVS     r0,#1
000010  f88d0003          STRB     r0,[sp,#3]
;;;922    	NVIC_Init(&NVIC_InitStructure);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       NVIC_Init
;;;923    #endif
;;;924    
;;;925    #if UART2_FIFO_EN == 1
;;;926    	/* 使能串口2中断 */
;;;927    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
00001a  2026              MOVS     r0,#0x26
00001c  f88d0000          STRB     r0,[sp,#0]
;;;928    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000020  2001              MOVS     r0,#1
000022  f88d0002          STRB     r0,[sp,#2]
;;;929    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000026  f88d0003          STRB     r0,[sp,#3]
;;;930    	NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;931    #endif
;;;932    
;;;933    #if UART3_FIFO_EN == 1
;;;934    	/* 使能串口3中断t */
;;;935    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
000030  2027              MOVS     r0,#0x27
000032  f88d0000          STRB     r0,[sp,#0]
;;;936    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
000036  2002              MOVS     r0,#2
000038  f88d0002          STRB     r0,[sp,#2]
;;;937    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003c  2001              MOVS     r0,#1
00003e  f88d0003          STRB     r0,[sp,#3]
;;;938    	NVIC_Init(&NVIC_InitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;939    #endif
;;;940    
;;;941    #if UART4_FIFO_EN == 1
;;;942    	/* 使能串口4中断t */
;;;943    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;944    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
;;;945    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;946    	NVIC_Init(&NVIC_InitStructure);
;;;947    #endif
;;;948    
;;;949    #if UART5_FIFO_EN == 1
;;;950    	/* 使能串口5中断t */
;;;951    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;952    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
;;;953    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;954    	NVIC_Init(&NVIC_InitStructure);
;;;955    #endif
;;;956    
;;;957    #if UART6_FIFO_EN == 1
;;;958    	/* 使能串口6中断t */
;;;959    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
000048  2047              MOVS     r0,#0x47
00004a  f88d0000          STRB     r0,[sp,#0]
;;;960    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
00004e  2005              MOVS     r0,#5
000050  f88d0002          STRB     r0,[sp,#2]
;;;961    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000054  2001              MOVS     r0,#1
000056  f88d0003          STRB     r0,[sp,#3]
;;;962    	NVIC_Init(&NVIC_InitStructure);
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       NVIC_Init
;;;963    #endif
;;;964    }
000060  bd08              POP      {r3,pc}
;;;965    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;504    */
;;;505    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;506    {
000002  b087              SUB      sp,sp,#0x1c
;;;507    	GPIO_InitTypeDef GPIO_InitStructure;
;;;508    	USART_InitTypeDef USART_InitStructure;
;;;509    
;;;510    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;511    
;;;512    	/* 第1步： 配置GPIO */
;;;513    	#if 1	/* TX = PA9   RX = PA10 */
;;;514    		/* 打开 GPIO 时钟 */
;;;515    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;516    
;;;517    		/* 打开 UART 时钟 */
;;;518    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2010              MOVS     r0,#0x10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;519    
;;;520    		/* 将 PA9 映射为 USART1_TX */
;;;521    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000014  2207              MOVS     r2,#7
000016  2109              MOVS     r1,#9
000018  48ab              LDR      r0,|L3.712|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;522    
;;;523    		/* 将 PA10 映射为 USART1_RX */
;;;524    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
00001e  2207              MOVS     r2,#7
000020  210a              MOVS     r1,#0xa
000022  48a9              LDR      r0,|L3.712|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;525    
;;;526    		/* 配置 USART Tx 为复用功能 */
;;;527    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000028  2000              MOVS     r0,#0
00002a  f88d001a          STRB     r0,[sp,#0x1a]
;;;528    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
00002e  2001              MOVS     r0,#1
000030  f88d001b          STRB     r0,[sp,#0x1b]
;;;529    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
000034  2002              MOVS     r0,#2
000036  f88d0018          STRB     r0,[sp,#0x18]
;;;530    
;;;531    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00003a  0200              LSLS     r0,r0,#8
00003c  9005              STR      r0,[sp,#0x14]
;;;532    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003e  2002              MOVS     r0,#2
000040  f88d0019          STRB     r0,[sp,#0x19]
;;;533    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000044  a905              ADD      r1,sp,#0x14
000046  48a0              LDR      r0,|L3.712|
000048  f7fffffe          BL       GPIO_Init
;;;534    
;;;535    		/* 配置 USART Rx 为复用功能 */
;;;536    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00004c  2002              MOVS     r0,#2
00004e  f88d0018          STRB     r0,[sp,#0x18]
;;;537    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000052  0240              LSLS     r0,r0,#9
000054  9005              STR      r0,[sp,#0x14]
;;;538    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000056  a905              ADD      r1,sp,#0x14
000058  489b              LDR      r0,|L3.712|
00005a  f7fffffe          BL       GPIO_Init
;;;539    	#else	/* TX = PB6   RX = PB7  */
;;;540    		/* 打开 GPIO 时钟 */
;;;541    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;542    
;;;543    		/* 打开 UART 时钟 */
;;;544    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;545    
;;;546    		/* 将 PB6 映射为 USART1_TX */
;;;547    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1);
;;;548    
;;;549    		/* 将 PB7 映射为 USART1_RX */
;;;550    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);
;;;551    
;;;552    		/* 配置 USART Tx 为复用功能 */
;;;553    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;554    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;555    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;556    
;;;557    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;558    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;559    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;560    
;;;561    		/* 配置 USART Rx 为复用功能 */
;;;562    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;563    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;564    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;565    	#endif
;;;566    
;;;567    	/* 第2步： 配置串口硬件参数 */
;;;568    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
00005e  f44f30e1          MOV      r0,#0x1c200
000062  9001              STR      r0,[sp,#4]
;;;569    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000064  2000              MOVS     r0,#0
000066  f8ad0008          STRH     r0,[sp,#8]
;;;570    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00006a  f8ad000a          STRH     r0,[sp,#0xa]
;;;571    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00006e  f8ad000c          STRH     r0,[sp,#0xc]
;;;572    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000072  f8ad0010          STRH     r0,[sp,#0x10]
;;;573    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000076  200c              MOVS     r0,#0xc
000078  f8ad000e          STRH     r0,[sp,#0xe]
;;;574    	USART_Init(USART1, &USART_InitStructure);
00007c  a901              ADD      r1,sp,#4
00007e  4893              LDR      r0,|L3.716|
000080  f7fffffe          BL       USART_Init
;;;575    
;;;576    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000084  2201              MOVS     r2,#1
000086  f2405125          MOV      r1,#0x525
00008a  4890              LDR      r0,|L3.716|
00008c  f7fffffe          BL       USART_ITConfig
;;;577    	/*
;;;578    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;579    		注意: 不要在此处打开发送中断
;;;580    		发送中断使能在SendUart()函数打开
;;;581    	*/
;;;582    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000090  2101              MOVS     r1,#1
000092  488e              LDR      r0,|L3.716|
000094  f7fffffe          BL       USART_Cmd
;;;583    
;;;584    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;585    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;586    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000098  2140              MOVS     r1,#0x40
00009a  488c              LDR      r0,|L3.716|
00009c  f7fffffe          BL       USART_ClearFlag
;;;587    #endif
;;;588    
;;;589    #if UART2_FIFO_EN == 1		/* 串口2 TX = PD5   RX = PD6 或  TX = PA2， RX = PA3  */
;;;590    	/* 第1步： 配置GPIO */
;;;591    	#if 0	/* 串口2 TX = PD5   RX = PD6 */
;;;592    		/* 打开 GPIO 时钟 */
;;;593    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
;;;594    
;;;595    		/* 打开 UART 时钟 */
;;;596    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;597    
;;;598    		/* 将 PD5 映射为 USART2_TX */
;;;599    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART2);
;;;600    
;;;601    		/* 将 PD6 映射为 USART2_RX */
;;;602    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART2);
;;;603    
;;;604    		/* 配置 USART Tx 为复用功能 */
;;;605    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;606    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;607    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;608    
;;;609    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;610    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;611    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;612    
;;;613    		/* 配置 USART Rx 为复用功能 */
;;;614    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;615    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;616    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;617    
;;;618    	#else	/* 串口2   TX = PA2， RX = PA3 */
;;;619    		/* 打开 GPIO 时钟 */
;;;620    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
0000a0  2101              MOVS     r1,#1
0000a2  4608              MOV      r0,r1
0000a4  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;621    
;;;622    		/* 打开 UART 时钟 */
;;;623    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  0448              LSLS     r0,r1,#17
0000ac  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;624    
;;;625    		/* 将 PA2 映射为 USART2_TX. 在STM32-V5板中，PA2 管脚用于以太网 */
;;;626    		//GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
;;;627    
;;;628    		/* 将 PA3 映射为 USART2_RX */
;;;629    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
0000b0  2207              MOVS     r2,#7
0000b2  2103              MOVS     r1,#3
0000b4  4884              LDR      r0,|L3.712|
0000b6  f7fffffe          BL       GPIO_PinAFConfig
;;;630    
;;;631    		/* 配置 USART Tx 为复用功能 */
;;;632    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
0000ba  2000              MOVS     r0,#0
0000bc  f88d001a          STRB     r0,[sp,#0x1a]
;;;633    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
0000c0  2001              MOVS     r0,#1
0000c2  f88d001b          STRB     r0,[sp,#0x1b]
;;;634    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
0000c6  2002              MOVS     r0,#2
0000c8  f88d0018          STRB     r0,[sp,#0x18]
;;;635    
;;;636    		//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;637    		//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;638    		//GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;639    
;;;640    		/* 配置 USART Rx 为复用功能 */
;;;641    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000cc  f88d0018          STRB     r0,[sp,#0x18]
;;;642    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000d0  2008              MOVS     r0,#8
0000d2  9005              STR      r0,[sp,#0x14]
;;;643    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000d4  2002              MOVS     r0,#2
0000d6  f88d0019          STRB     r0,[sp,#0x19]
;;;644    		GPIO_Init(GPIOA, &GPIO_InitStructure);
0000da  a905              ADD      r1,sp,#0x14
0000dc  487a              LDR      r0,|L3.712|
0000de  f7fffffe          BL       GPIO_Init
;;;645    	#endif
;;;646    
;;;647    	/* 第2步： 配置串口硬件参数 */
;;;648    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
0000e2  f44f5016          MOV      r0,#0x2580
0000e6  9001              STR      r0,[sp,#4]
;;;649    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000e8  2000              MOVS     r0,#0
0000ea  f8ad0008          STRH     r0,[sp,#8]
;;;650    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000ee  f8ad000a          STRH     r0,[sp,#0xa]
;;;651    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000f2  f8ad000c          STRH     r0,[sp,#0xc]
;;;652    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000f6  f8ad0010          STRH     r0,[sp,#0x10]
;;;653    	USART_InitStructure.USART_Mode = USART_Mode_Rx;		/* 仅选择接收模式 */
0000fa  2004              MOVS     r0,#4
0000fc  f8ad000e          STRH     r0,[sp,#0xe]
;;;654    	USART_Init(USART2, &USART_InitStructure);
000100  a901              ADD      r1,sp,#4
000102  4873              LDR      r0,|L3.720|
000104  f7fffffe          BL       USART_Init
;;;655    
;;;656    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000108  2201              MOVS     r2,#1
00010a  f2405125          MOV      r1,#0x525
00010e  4870              LDR      r0,|L3.720|
000110  f7fffffe          BL       USART_ITConfig
;;;657    	/*
;;;658    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;659    		注意: 不要在此处打开发送中断
;;;660    		发送中断使能在SendUart()函数打开
;;;661    	*/
;;;662    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
000114  2101              MOVS     r1,#1
000116  486e              LDR      r0,|L3.720|
000118  f7fffffe          BL       USART_Cmd
;;;663    
;;;664    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;665    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;666    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00011c  2140              MOVS     r1,#0x40
00011e  486c              LDR      r0,|L3.720|
000120  f7fffffe          BL       USART_ClearFlag
;;;667    #endif
;;;668    
;;;669    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;670    
;;;671    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;672    	{
;;;673    		RCC_AHB1PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
000124  2101              MOVS     r1,#1
000126  2002              MOVS     r0,#2
000128  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;674    
;;;675    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00012c  2001              MOVS     r0,#1
00012e  f88d0018          STRB     r0,[sp,#0x18]
;;;676    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000132  2000              MOVS     r0,#0
000134  f88d001a          STRB     r0,[sp,#0x1a]
;;;677    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000138  f88d001b          STRB     r0,[sp,#0x1b]
;;;678    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00013c  2003              MOVS     r0,#3
00013e  f88d0019          STRB     r0,[sp,#0x19]
;;;679    
;;;680    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000142  2004              MOVS     r0,#4
000144  9005              STR      r0,[sp,#0x14]
;;;681    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
000146  a905              ADD      r1,sp,#0x14
000148  4862              LDR      r0,|L3.724|
00014a  f7fffffe          BL       GPIO_Init
;;;682    	}
;;;683    
;;;684    	/* 打开 GPIO 时钟 */
;;;685    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
00014e  2101              MOVS     r1,#1
000150  2002              MOVS     r0,#2
000152  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;686    
;;;687    	/* 打开 UART 时钟 */
;;;688    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000156  2101              MOVS     r1,#1
000158  0488              LSLS     r0,r1,#18
00015a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;689    
;;;690    	/* 将 PB10 映射为 USART3_TX */
;;;691    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_USART3);
00015e  2207              MOVS     r2,#7
000160  210a              MOVS     r1,#0xa
000162  485c              LDR      r0,|L3.724|
000164  f7fffffe          BL       GPIO_PinAFConfig
;;;692    
;;;693    	/* 将 PB11 映射为 USART3_RX */
;;;694    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_USART3);
000168  2207              MOVS     r2,#7
00016a  210b              MOVS     r1,#0xb
00016c  4859              LDR      r0,|L3.724|
00016e  f7fffffe          BL       GPIO_PinAFConfig
;;;695    
;;;696    	/* 配置 USART Tx 为复用功能 */
;;;697    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000172  2000              MOVS     r0,#0
000174  f88d001a          STRB     r0,[sp,#0x1a]
;;;698    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
000178  2001              MOVS     r0,#1
00017a  f88d001b          STRB     r0,[sp,#0x1b]
;;;699    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
00017e  2002              MOVS     r0,#2
000180  f88d0018          STRB     r0,[sp,#0x18]
;;;700    
;;;701    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000184  0240              LSLS     r0,r0,#9
000186  9005              STR      r0,[sp,#0x14]
;;;702    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000188  2002              MOVS     r0,#2
00018a  f88d0019          STRB     r0,[sp,#0x19]
;;;703    	GPIO_Init(GPIOB, &GPIO_InitStructure);
00018e  a905              ADD      r1,sp,#0x14
000190  4850              LDR      r0,|L3.724|
000192  f7fffffe          BL       GPIO_Init
;;;704    
;;;705    	/* 配置 USART Rx 为复用功能 */
;;;706    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000196  2002              MOVS     r0,#2
000198  f88d0018          STRB     r0,[sp,#0x18]
;;;707    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
00019c  0280              LSLS     r0,r0,#10
00019e  9005              STR      r0,[sp,#0x14]
;;;708    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0001a0  a905              ADD      r1,sp,#0x14
0001a2  484c              LDR      r0,|L3.724|
0001a4  f7fffffe          BL       GPIO_Init
;;;709    
;;;710    	/* 第2步： 配置串口硬件参数 */
;;;711    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
0001a8  f44f5016          MOV      r0,#0x2580
0001ac  9001              STR      r0,[sp,#4]
;;;712    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001ae  2000              MOVS     r0,#0
0001b0  f8ad0008          STRH     r0,[sp,#8]
;;;713    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001b4  f8ad000a          STRH     r0,[sp,#0xa]
;;;714    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0001b8  f8ad000c          STRH     r0,[sp,#0xc]
;;;715    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0001bc  f8ad0010          STRH     r0,[sp,#0x10]
;;;716    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001c0  200c              MOVS     r0,#0xc
0001c2  f8ad000e          STRH     r0,[sp,#0xe]
;;;717    	USART_Init(USART3, &USART_InitStructure);
0001c6  a901              ADD      r1,sp,#4
0001c8  4843              LDR      r0,|L3.728|
0001ca  f7fffffe          BL       USART_Init
;;;718    
;;;719    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0001ce  2201              MOVS     r2,#1
0001d0  f2405125          MOV      r1,#0x525
0001d4  4840              LDR      r0,|L3.728|
0001d6  f7fffffe          BL       USART_ITConfig
;;;720    	/*
;;;721    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;722    		注意: 不要在此处打开发送中断
;;;723    		发送中断使能在SendUart()函数打开
;;;724    	*/
;;;725    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
0001da  2101              MOVS     r1,#1
0001dc  483e              LDR      r0,|L3.728|
0001de  f7fffffe          BL       USART_Cmd
;;;726    
;;;727    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;728    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;729    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0001e2  2140              MOVS     r1,#0x40
0001e4  483c              LDR      r0,|L3.728|
0001e6  f7fffffe          BL       USART_ClearFlag
;;;730    #endif
;;;731    
;;;732    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;733    	/* 第1步： 配置GPIO */
;;;734    
;;;735    	/* 打开 GPIO 时钟 */
;;;736    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
;;;737    
;;;738    	/* 打开 UART 时钟 */
;;;739    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;740    
;;;741    	/* 将 PC10 映射为 UART4_TX */
;;;742    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;743    
;;;744    	/* 将 PC11 映射为 UART4_RX */
;;;745    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;746    
;;;747    	/* 配置 USART Tx 为复用功能 */
;;;748    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;749    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;750    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;751    
;;;752    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;753    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;754    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;755    
;;;756    	/* 配置 USART Rx 为复用功能 */
;;;757    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;758    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;759    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;760    
;;;761    	/* 第2步： 配置串口硬件参数 */
;;;762    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;763    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;764    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;765    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;766    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;767    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;768    	USART_Init(UART4, &USART_InitStructure);
;;;769    
;;;770    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;771    	/*
;;;772    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;773    		注意: 不要在此处打开发送中断
;;;774    		发送中断使能在SendUart()函数打开
;;;775    	*/
;;;776    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;777    
;;;778    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;779    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;780    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;781    #endif
;;;782    
;;;783    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;784    	/* 第1步： 配置GPIO */
;;;785    
;;;786    	/* 打开 GPIO 时钟 */
;;;787    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOD, ENABLE);
;;;788    
;;;789    	/* 打开 UART 时钟 */
;;;790    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;791    
;;;792    	/* 将 PC12 映射为 UART5_TX */
;;;793    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_UART5);
;;;794    
;;;795    	/* 将 PD2 映射为 UART5_RX */
;;;796    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_UART5);
;;;797    
;;;798    	/* 配置 UART Tx 为复用功能 */
;;;799    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;800    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;801    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;802    
;;;803    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;804    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;805    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;806    
;;;807    	/* 配置 UART Rx 为复用功能 */
;;;808    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;809    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;810    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;811    
;;;812    	/* 第2步： 配置串口硬件参数 */
;;;813    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;814    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;815    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;816    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;817    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;818    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;819    	USART_Init(UART5, &USART_InitStructure);
;;;820    
;;;821    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;822    	/*
;;;823    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;824    		注意: 不要在此处打开发送中断
;;;825    		发送中断使能在SendUart()函数打开
;;;826    	*/
;;;827    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;828    
;;;829    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;830    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;831    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;832    #endif
;;;833    
;;;834    #if UART6_FIFO_EN == 1			/* PG14/USART6_TX , PC7/USART6_RX,PG8/USART6_RTS, PG15/USART6_CTS */
;;;835    	/* 第1步： 配置GPIO */
;;;836    
;;;837    	/* 打开 GPIO 时钟 */
;;;838    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOG, ENABLE);
0001ea  2101              MOVS     r1,#1
0001ec  2044              MOVS     r0,#0x44
0001ee  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;839    
;;;840    	/* 打开 UART 时钟 */
;;;841    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
0001f2  2101              MOVS     r1,#1
0001f4  2020              MOVS     r0,#0x20
0001f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;842    
;;;843    	/* 将 PG14 映射为 USART6_TX */
;;;844    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_USART6);
0001fa  2208              MOVS     r2,#8
0001fc  210e              MOVS     r1,#0xe
0001fe  4837              LDR      r0,|L3.732|
000200  f7fffffe          BL       GPIO_PinAFConfig
;;;845    
;;;846    	/* 将 PC7 映射为 USART6_RX */
;;;847    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_USART6);
000204  2208              MOVS     r2,#8
000206  2107              MOVS     r1,#7
000208  4835              LDR      r0,|L3.736|
00020a  f7fffffe          BL       GPIO_PinAFConfig
;;;848    
;;;849    	/* 将 PG8 映射为 USART6_RTS */
;;;850    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource8, GPIO_AF_USART6);
00020e  2208              MOVS     r2,#8
000210  4611              MOV      r1,r2
000212  4832              LDR      r0,|L3.732|
000214  f7fffffe          BL       GPIO_PinAFConfig
;;;851    
;;;852    	/* 将 PG15 映射为 USART6_CTS */
;;;853    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource15, GPIO_AF_USART6);
000218  2208              MOVS     r2,#8
00021a  210f              MOVS     r1,#0xf
00021c  482f              LDR      r0,|L3.732|
00021e  f7fffffe          BL       GPIO_PinAFConfig
;;;854    
;;;855    	/* 配置 PG14/USART6_TX 为复用功能 */
;;;856    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000222  2000              MOVS     r0,#0
000224  f88d001a          STRB     r0,[sp,#0x1a]
;;;857    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
000228  2001              MOVS     r0,#1
00022a  f88d001b          STRB     r0,[sp,#0x1b]
;;;858    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
00022e  2002              MOVS     r0,#2
000230  f88d0018          STRB     r0,[sp,#0x18]
;;;859    
;;;860    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
000234  0340              LSLS     r0,r0,#13
000236  9005              STR      r0,[sp,#0x14]
;;;861    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000238  2002              MOVS     r0,#2
00023a  f88d0019          STRB     r0,[sp,#0x19]
;;;862    	GPIO_Init(GPIOG, &GPIO_InitStructure);
00023e  a905              ADD      r1,sp,#0x14
000240  4826              LDR      r0,|L3.732|
000242  f7fffffe          BL       GPIO_Init
;;;863    
;;;864    	/* 配置 PC7/USART6_RX 为复用功能 */
;;;865    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000246  2002              MOVS     r0,#2
000248  f88d0018          STRB     r0,[sp,#0x18]
;;;866    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
00024c  2080              MOVS     r0,#0x80
00024e  9005              STR      r0,[sp,#0x14]
;;;867    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000250  a905              ADD      r1,sp,#0x14
000252  4823              LDR      r0,|L3.736|
000254  f7fffffe          BL       GPIO_Init
;;;868    
;;;869    	/* 配置 PG8/USART6_RTS 为复用功能 */
;;;870    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000258  2002              MOVS     r0,#2
00025a  f88d0018          STRB     r0,[sp,#0x18]
;;;871    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
00025e  01c0              LSLS     r0,r0,#7
000260  9005              STR      r0,[sp,#0x14]
;;;872    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000262  a905              ADD      r1,sp,#0x14
000264  481d              LDR      r0,|L3.732|
000266  f7fffffe          BL       GPIO_Init
;;;873    
;;;874    	/* 配置 PG15/USART6_CTS 为复用功能 */
;;;875    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00026a  2002              MOVS     r0,#2
00026c  f88d0018          STRB     r0,[sp,#0x18]
;;;876    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
000270  0380              LSLS     r0,r0,#14
000272  9005              STR      r0,[sp,#0x14]
;;;877    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000274  a905              ADD      r1,sp,#0x14
000276  4819              LDR      r0,|L3.732|
000278  f7fffffe          BL       GPIO_Init
;;;878    
;;;879    	/* 第2步： 配置串口硬件参数 */
;;;880    	USART_InitStructure.USART_BaudRate = UART6_BAUD;	/* 波特率 */
00027c  f44f30e1          MOV      r0,#0x1c200
000280  9001              STR      r0,[sp,#4]
;;;881    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000282  2000              MOVS     r0,#0
000284  f8ad0008          STRH     r0,[sp,#8]
;;;882    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000288  f8ad000a          STRH     r0,[sp,#0xa]
;;;883    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00028c  f8ad000c          STRH     r0,[sp,#0xc]
;;;884    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_RTS_CTS;	/* 选择硬件流控 */
000290  f44f7040          MOV      r0,#0x300
000294  f8ad0010          STRH     r0,[sp,#0x10]
;;;885    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000298  200c              MOVS     r0,#0xc
00029a  f8ad000e          STRH     r0,[sp,#0xe]
;;;886    	USART_Init(USART6, &USART_InitStructure);
00029e  a901              ADD      r1,sp,#4
0002a0  4810              LDR      r0,|L3.740|
0002a2  f7fffffe          BL       USART_Init
;;;887    
;;;888    	USART_ITConfig(USART6, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0002a6  2201              MOVS     r2,#1
0002a8  f2405125          MOV      r1,#0x525
0002ac  480d              LDR      r0,|L3.740|
0002ae  f7fffffe          BL       USART_ITConfig
;;;889    	/*
;;;890    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;891    		注意: 不要在此处打开发送中断
;;;892    		发送中断使能在SendUart()函数打开
;;;893    	*/
;;;894    	USART_Cmd(USART6, ENABLE);		/* 使能串口 */
0002b2  2101              MOVS     r1,#1
0002b4  480b              LDR      r0,|L3.740|
0002b6  f7fffffe          BL       USART_Cmd
;;;895    
;;;896    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;897    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;898    	USART_ClearFlag(USART6, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0002ba  2140              MOVS     r1,#0x40
0002bc  4809              LDR      r0,|L3.740|
0002be  f7fffffe          BL       USART_ClearFlag
;;;899    #endif
;;;900    }
0002c2  b007              ADD      sp,sp,#0x1c
0002c4  bd00              POP      {pc}
;;;901    
                          ENDP

0002c6  0000              DCW      0x0000
                  |L3.712|
                          DCD      0x40020000
                  |L3.716|
                          DCD      0x40011000
                  |L3.720|
                          DCD      0x40004400
                  |L3.724|
                          DCD      0x40020400
                  |L3.728|
                          DCD      0x40004800
                  |L3.732|
                          DCD      0x40021800
                  |L3.736|
                          DCD      0x40020800
                  |L3.740|
                          DCD      0x40011400

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;275    */
;;;276    void RS485_InitTXE(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;277    {
;;;278    	GPIO_InitTypeDef GPIO_InitStructure;
;;;279    
;;;280    	RCC_AHB1PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;281    
;;;282    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;283    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;284    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无上拉电阻 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;285    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;286    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000020  2004              MOVS     r0,#4
000022  9000              STR      r0,[sp,#0]
;;;287    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4802              LDR      r0,|L4.48|
000028  f7fffffe          BL       GPIO_Init
;;;288    }
00002c  bd1c              POP      {r2-r4,pc}
;;;289    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x40020400

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;377    extern void MODBUS_ReciveNew(uint8_t _byte);
;;;378    void RS485_ReciveNew(uint8_t _byte)
000000  b510              PUSH     {r4,lr}
;;;379    {
000002  4604              MOV      r4,r0
;;;380    	MODBUS_ReciveNew(_byte);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       MODBUS_ReciveNew
;;;381    }
00000a  bd10              POP      {r4,pc}
;;;382    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;320    */
;;;321    void RS485_SendBefor(void)
000000  2004              MOVS     r0,#4
;;;322    {
;;;323    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L6.8|
000004  8008              STRH     r0,[r1,#0]
;;;324    }
000006  4770              BX       lr
;;;325    
                          ENDP

                  |L6.8|
                          DCD      0x40020418

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;348    */
;;;349    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;350    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;351    	comSendBuf(COM3, _ucaBuf, _usLen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       comSendBuf
;;;352    }
000010  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;334    */
;;;335    void RS485_SendOver(void)
000000  2004              MOVS     r0,#4
;;;336    {
;;;337    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L8.8|
000004  8008              STRH     r0,[r1,#0]
;;;338    }
000006  4770              BX       lr
;;;339    
                          ENDP

                  |L8.8|
                          DCD      0x4002041a

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;363    */
;;;364    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
000002  4604              MOV      r4,r0
;;;366    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;367    }
000014  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1200   #if UART1_FIFO_EN == 1
;;;1201   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1202   {
;;;1203   	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L10.12|
000004  f7fffffe          BL       UartIRQ
;;;1204   }
000008  bd10              POP      {r4,pc}
;;;1205   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1207   #if UART2_FIFO_EN == 1
;;;1208   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1209   {
;;;1210   	UartIRQ(&g_tUart2);
000002  4802              LDR      r0,|L11.12|
000004  f7fffffe          BL       UartIRQ
;;;1211   }
000008  bd10              POP      {r4,pc}
;;;1212   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      g_tUart2

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;1214   #if UART3_FIFO_EN == 1
;;;1215   void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1216   {
;;;1217   	UartIRQ(&g_tUart3);
000002  4802              LDR      r0,|L12.12|
000004  f7fffffe          BL       UartIRQ
;;;1218   }
000008  bd10              POP      {r4,pc}
;;;1219   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      g_tUart3

                          AREA ||i.USART6_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART6_IRQHandler PROC
;;;1235   #if UART6_FIFO_EN == 1
;;;1236   void USART6_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1237   {
;;;1238   	UartIRQ(&g_tUart6);
000002  4802              LDR      r0,|L13.12|
000004  f7fffffe          BL       UartIRQ
;;;1239   }
000008  bd10              POP      {r4,pc}
;;;1240   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      g_tUart6

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;1045   */
;;;1046   static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;1047   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1048   	uint16_t usCount;
;;;1049   
;;;1050   	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;1051   	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;1052   	usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;1053   	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;1054   
;;;1055   	/* 如果读和写索引相同，则返回0 */
;;;1056   	//if (_pUart->usRxRead == usRxWrite)
;;;1057   	if (usCount == 0)	/* 已经没有数据 */  //实质是判断_pUart->usRxCount是多少
000014  b90e              CBNZ     r6,|L14.26|
;;;1058   	{
;;;1059   		return 0;
000016  2000              MOVS     r0,#0
                  |L14.24|
;;;1060   	}
;;;1061   	else
;;;1062   	{
;;;1063   		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;1064   
;;;1065   		/* 改写FIFO读索引 */
;;;1066   		DISABLE_INT();
;;;1067   		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;1068   		{
;;;1069   			_pUart->usRxRead = 0;
;;;1070   		}
;;;1071   		_pUart->usRxCount--;
;;;1072   		ENABLE_INT();
;;;1073   		return 1;
;;;1074   	}
;;;1075   }
000018  bd70              POP      {r4-r6,pc}
                  |L14.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;1063
00001c  68a0              LDR      r0,[r4,#8]            ;1063
00001e  5c40              LDRB     r0,[r0,r1]            ;1063
000020  7028              STRB     r0,[r5,#0]            ;1063
000022  2001              MOVS     r0,#1                 ;1066
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;1067
00002a  1c40              ADDS     r0,r0,#1              ;1067
00002c  b280              UXTH     r0,r0                 ;1067
00002e  8320              STRH     r0,[r4,#0x18]         ;1067
000030  89e1              LDRH     r1,[r4,#0xe]          ;1067
000032  4288              CMP      r0,r1                 ;1067
000034  db01              BLT      |L14.58|
000036  2000              MOVS     r0,#0                 ;1069
000038  8320              STRH     r0,[r4,#0x18]         ;1069
                  |L14.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;1071
00003c  1e40              SUBS     r0,r0,#1              ;1071
00003e  8360              STRH     r0,[r4,#0x1a]         ;1071
000040  2000              MOVS     r0,#0                 ;1072
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;1073
000048  e7e6              B        |L14.24|
;;;1076   
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=2

                  UartIRQ PROC
;;;1084   */
;;;1085   static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;1086   {
000002  4604              MOV      r4,r0
;;;1087   	/* 处理接收中断  */
;;;1088   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d04d              BEQ      |L15.174|
;;;1089   	{
;;;1090   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1091   		uint8_t ch;
;;;1092   
;;;1093   		ch = USART_ReceiveData(_pUart->uart);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USART_ReceiveData
000018  b2c5              UXTB     r5,r0
;;;1094   		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
00001a  8ae1              LDRH     r1,[r4,#0x16]
00001c  68a0              LDR      r0,[r4,#8]
00001e  5445              STRB     r5,[r0,r1]
;;;1095   		
;;;1096   		//以下代码移植正点原子  0x0d 0x0a 没有算到USART_RX_STA
;;;1097   		//同时接收到的数据，存到数组_pUart->pRxBuf[_pUart->usRxWrite] 
;;;1098   		//所以删去了源代码中储存的部分代码
;;;1099   		if((USART_RX_STA & 0x8000) == 0) //还未接收0X0a 
000020  484a              LDR      r0,|L15.332|
000022  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000024  f4004000          AND      r0,r0,#0x8000
000028  bb58              CBNZ     r0,|L15.130|
;;;1100   		{
;;;1101   			if(USART_RX_STA&0x4000)//接收到了0x0d
00002a  4848              LDR      r0,|L15.332|
00002c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00002e  f4004080          AND      r0,r0,#0x4000
000032  b160              CBZ      r0,|L15.78|
;;;1102   			{
;;;1103   				if(ch!=0x0a)USART_RX_STA=0;//接收错误,重新开始
000034  2d0a              CMP      r5,#0xa
000036  d003              BEQ      |L15.64|
000038  2000              MOVS     r0,#0
00003a  4944              LDR      r1,|L15.332|
00003c  8008              STRH     r0,[r1,#0]
00003e  e020              B        |L15.130|
                  |L15.64|
;;;1104   				else USART_RX_STA|=0x8000;	//接收完成了 
000040  4842              LDR      r0,|L15.332|
000042  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000044  f4404000          ORR      r0,r0,#0x8000
000048  4940              LDR      r1,|L15.332|
00004a  8008              STRH     r0,[r1,#0]
00004c  e019              B        |L15.130|
                  |L15.78|
;;;1105   			}
;;;1106   			else
;;;1107   			{
;;;1108   				if(ch==0x0d)USART_RX_STA|=0x4000;
00004e  2d0d              CMP      r5,#0xd
000050  d106              BNE      |L15.96|
000052  483e              LDR      r0,|L15.332|
000054  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000056  f4404080          ORR      r0,r0,#0x4000
00005a  493c              LDR      r1,|L15.332|
00005c  8008              STRH     r0,[r1,#0]
00005e  e010              B        |L15.130|
                  |L15.96|
;;;1109   				else
;;;1110   				{
;;;1111   					USART_RX_BUF[USART_RX_STA&0X3FFF]=ch;
000060  483a              LDR      r0,|L15.332|
000062  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000064  f3c0000d          UBFX     r0,r0,#0,#14
000068  4939              LDR      r1,|L15.336|
00006a  540d              STRB     r5,[r1,r0]
;;;1112   					USART_RX_STA++;
00006c  4837              LDR      r0,|L15.332|
00006e  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000070  1c40              ADDS     r0,r0,#1
000072  4936              LDR      r1,|L15.332|
000074  8008              STRH     r0,[r1,#0]
;;;1113   					if(USART_RX_STA>(200-1))USART_RX_STA=0;//接收数据错误,重新开始接收
000076  4608              MOV      r0,r1
000078  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00007a  28c7              CMP      r0,#0xc7
00007c  dd01              BLE      |L15.130|
00007e  2000              MOVS     r0,#0
000080  8008              STRH     r0,[r1,#0]
                  |L15.130|
;;;1114   				}	
;;;1115   			}
;;;1116   		}
;;;1117   		
;;;1118   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
000082  8ae0              LDRH     r0,[r4,#0x16]
000084  1c40              ADDS     r0,r0,#1
000086  b280              UXTH     r0,r0
000088  82e0              STRH     r0,[r4,#0x16]
00008a  89e1              LDRH     r1,[r4,#0xe]
00008c  4288              CMP      r0,r1
00008e  db01              BLT      |L15.148|
;;;1119   		{
;;;1120   			_pUart->usRxWrite = 0;   //越界后，_pUart->usRxWrite = 0
000090  2000              MOVS     r0,#0
000092  82e0              STRH     r0,[r4,#0x16]
                  |L15.148|
;;;1121   		}
;;;1122   		if (_pUart->usRxCount < _pUart->usRxBufSize)
000094  8b60              LDRH     r0,[r4,#0x1a]
000096  89e1              LDRH     r1,[r4,#0xe]
000098  4288              CMP      r0,r1
00009a  da02              BGE      |L15.162|
;;;1123   		{
;;;1124   			_pUart->usRxCount++;     //计算读出到的数据个数
00009c  8b60              LDRH     r0,[r4,#0x1a]
00009e  1c40              ADDS     r0,r0,#1
0000a0  8360              STRH     r0,[r4,#0x1a]
                  |L15.162|
;;;1125   		}
;;;1126   
;;;1127   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1128   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1129   		//if (_pUart->usRxCount == 1)
;;;1130   		{
;;;1131   			if (_pUart->ReciveNew)
0000a2  6a60              LDR      r0,[r4,#0x24]
0000a4  b110              CBZ      r0,|L15.172|
;;;1132   			{
;;;1133   				_pUart->ReciveNew(ch);
0000a6  4628              MOV      r0,r5
0000a8  6a61              LDR      r1,[r4,#0x24]
0000aa  4788              BLX      r1
                  |L15.172|
;;;1134   			}
;;;1135   		}
;;;1136   	}
0000ac  bf00              NOP      
                  |L15.174|
;;;1137   
;;;1138   	/* 处理发送缓冲区空中断 */
;;;1139   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
0000ae  f2407127          MOV      r1,#0x727
0000b2  6820              LDR      r0,[r4,#0]
0000b4  f7fffffe          BL       USART_GetITStatus
0000b8  b308              CBZ      r0,|L15.254|
;;;1140   	{
;;;1141   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1142   		if (_pUart->usTxCount == 0)
0000ba  8aa0              LDRH     r0,[r4,#0x14]
0000bc  b960              CBNZ     r0,|L15.216|
;;;1143   		{
;;;1144   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1145   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
0000be  2200              MOVS     r2,#0
0000c0  f2407127          MOV      r1,#0x727
0000c4  6820              LDR      r0,[r4,#0]
0000c6  f7fffffe          BL       USART_ITConfig
;;;1146   
;;;1147   			/* 使能数据发送完毕中断 */
;;;1148   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
0000ca  2201              MOVS     r2,#1
0000cc  f2406126          MOV      r1,#0x626
0000d0  6820              LDR      r0,[r4,#0]
0000d2  f7fffffe          BL       USART_ITConfig
0000d6  e037              B        |L15.328|
                  |L15.216|
;;;1149   		}
;;;1150   		else
;;;1151   		{
;;;1152   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1153   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000d8  8a63              LDRH     r3,[r4,#0x12]
0000da  6862              LDR      r2,[r4,#4]
0000dc  5cd1              LDRB     r1,[r2,r3]
0000de  6820              LDR      r0,[r4,#0]
0000e0  f7fffffe          BL       USART_SendData
;;;1154   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000e4  8a60              LDRH     r0,[r4,#0x12]
0000e6  1c40              ADDS     r0,r0,#1
0000e8  b280              UXTH     r0,r0
0000ea  8260              STRH     r0,[r4,#0x12]
0000ec  89a1              LDRH     r1,[r4,#0xc]
0000ee  4288              CMP      r0,r1
0000f0  db01              BLT      |L15.246|
;;;1155   			{
;;;1156   				_pUart->usTxRead = 0;
0000f2  2000              MOVS     r0,#0
0000f4  8260              STRH     r0,[r4,#0x12]
                  |L15.246|
;;;1157   			}
;;;1158   			_pUart->usTxCount--;
0000f6  8aa0              LDRH     r0,[r4,#0x14]
0000f8  1e40              SUBS     r0,r0,#1
0000fa  82a0              STRH     r0,[r4,#0x14]
0000fc  e024              B        |L15.328|
                  |L15.254|
;;;1159   		}
;;;1160   
;;;1161   	}
;;;1162   	/* 数据bit位全部发送完毕的中断 */
;;;1163   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
0000fe  f2406126          MOV      r1,#0x626
000102  6820              LDR      r0,[r4,#0]
000104  f7fffffe          BL       USART_GetITStatus
000108  b1f0              CBZ      r0,|L15.328|
;;;1164   	{
;;;1165   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1166   		if (_pUart->usTxCount == 0)
00010a  8aa0              LDRH     r0,[r4,#0x14]
00010c  b950              CBNZ     r0,|L15.292|
;;;1167   		{
;;;1168   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1169   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
00010e  2200              MOVS     r2,#0
000110  f2406126          MOV      r1,#0x626
000114  6820              LDR      r0,[r4,#0]
000116  f7fffffe          BL       USART_ITConfig
;;;1170   
;;;1171   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1172   			if (_pUart->SendOver)
00011a  6a20              LDR      r0,[r4,#0x20]
00011c  b1a0              CBZ      r0,|L15.328|
;;;1173   			{
;;;1174   				_pUart->SendOver();
00011e  6a20              LDR      r0,[r4,#0x20]
000120  4780              BLX      r0
000122  e011              B        |L15.328|
                  |L15.292|
;;;1175   			}
;;;1176   		}
;;;1177   		else
;;;1178   		{
;;;1179   			/* 正常情况下，不会进入此分支 */
;;;1180   
;;;1181   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1182   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000124  8a63              LDRH     r3,[r4,#0x12]
000126  6862              LDR      r2,[r4,#4]
000128  5cd1              LDRB     r1,[r2,r3]
00012a  6820              LDR      r0,[r4,#0]
00012c  f7fffffe          BL       USART_SendData
;;;1183   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000130  8a60              LDRH     r0,[r4,#0x12]
000132  1c40              ADDS     r0,r0,#1
000134  b280              UXTH     r0,r0
000136  8260              STRH     r0,[r4,#0x12]
000138  89a1              LDRH     r1,[r4,#0xc]
00013a  4288              CMP      r0,r1
00013c  db01              BLT      |L15.322|
;;;1184   			{
;;;1185   				_pUart->usTxRead = 0;
00013e  2000              MOVS     r0,#0
000140  8260              STRH     r0,[r4,#0x12]
                  |L15.322|
;;;1186   			}
;;;1187   			_pUart->usTxCount--;
000142  8aa0              LDRH     r0,[r4,#0x14]
000144  1e40              SUBS     r0,r0,#1
000146  82a0              STRH     r0,[r4,#0x14]
                  |L15.328|
;;;1188   		}
;;;1189   	}
;;;1190   }
000148  bd70              POP      {r4-r6,pc}
;;;1191   
                          ENDP

00014a  0000              DCW      0x0000
                  |L15.332|
                          DCD      USART_RX_STA
                  |L15.336|
                          DCD      USART_RX_BUF

                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;973    */
;;;974    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;975    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;976    	uint16_t i;
;;;977    
;;;978    	for (i = 0; i < _usLen; i++)
00000a  2500              MOVS     r5,#0
00000c  e027              B        |L16.94|
                  |L16.14|
;;;979    	{
;;;980    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;981    	#if 0
;;;982    		/*
;;;983    			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;984    			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;985    			将导致while(1) 无法退出
;;;986    		*/
;;;987    		while (1)
;;;988    		{
;;;989    			uint16_t usRead;
;;;990    
;;;991    			DISABLE_INT();
;;;992    			usRead = _pUart->usTxRead;
;;;993    			ENABLE_INT();
;;;994    
;;;995    			if (++usRead >= _pUart->usTxBufSize)
;;;996    			{
;;;997    				usRead = 0;
;;;998    			}
;;;999    
;;;1000   			if (usRead != _pUart->usTxWrite)
;;;1001   			{
;;;1002   				break;
;;;1003   			}
;;;1004   		}
;;;1005   	#else
;;;1006   		/* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;1007   		while (1)
00000e  e00c              B        |L16.42|
                  |L16.16|
;;;1008   		{
;;;1009   			uint16_t usCount;
;;;1010   
;;;1011   			DISABLE_INT();
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __set_PRIMASK
;;;1012   			usCount = _pUart->usTxCount;
000016  f8b48014          LDRH     r8,[r4,#0x14]
;;;1013   			ENABLE_INT();
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       __set_PRIMASK
;;;1014   
;;;1015   			if (usCount < _pUart->usTxBufSize)
000020  89a0              LDRH     r0,[r4,#0xc]
000022  4540              CMP      r0,r8
000024  dd00              BLE      |L16.40|
;;;1016   			{
;;;1017   				break;
000026  e001              B        |L16.44|
                  |L16.40|
;;;1018   			}
;;;1019   		}
000028  bf00              NOP      
                  |L16.42|
00002a  e7f1              B        |L16.16|
                  |L16.44|
00002c  bf00              NOP                            ;1017
;;;1020   	#endif
;;;1021   
;;;1022   		/* 将新数据填入发送缓冲区 */
;;;1023   		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00002e  5d70              LDRB     r0,[r6,r5]
000030  8a22              LDRH     r2,[r4,#0x10]
000032  6861              LDR      r1,[r4,#4]
000034  5488              STRB     r0,[r1,r2]
;;;1024   
;;;1025   		DISABLE_INT();
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       __set_PRIMASK
;;;1026   		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
00003c  8a20              LDRH     r0,[r4,#0x10]
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
000042  8220              STRH     r0,[r4,#0x10]
000044  89a1              LDRH     r1,[r4,#0xc]
000046  4288              CMP      r0,r1
000048  db01              BLT      |L16.78|
;;;1027   		{
;;;1028   			_pUart->usTxWrite = 0;
00004a  2000              MOVS     r0,#0
00004c  8220              STRH     r0,[r4,#0x10]
                  |L16.78|
;;;1029   		}
;;;1030   		_pUart->usTxCount++;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  1c40              ADDS     r0,r0,#1
000052  82a0              STRH     r0,[r4,#0x14]
;;;1031   		ENABLE_INT();
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       __set_PRIMASK
00005a  1c68              ADDS     r0,r5,#1              ;978
00005c  b285              UXTH     r5,r0                 ;978
                  |L16.94|
00005e  42bd              CMP      r5,r7                 ;978
000060  dbd5              BLT      |L16.14|
;;;1032   	}
;;;1033   
;;;1034   	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000062  2201              MOVS     r2,#1
000064  f2407127          MOV      r1,#0x727
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       USART_ITConfig
;;;1035   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1036   
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;390    */
;;;391    static void UartVarInit(void)
000000  482b              LDR      r0,|L17.176|
;;;392    {
;;;393    #if UART1_FIFO_EN == 1
;;;394    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  492c              LDR      r1,|L17.180|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;395    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  482c              LDR      r0,|L17.184|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;396    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  482c              LDR      r0,|L17.188|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;397    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f6080          MOV      r0,#0x400
000012  8188              STRH     r0,[r1,#0xc]
;;;398    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;399    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;400    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;401    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;402    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;403    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;404    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;405    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;406    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;407    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;408    #endif
;;;409    
;;;410    #if UART2_FIFO_EN == 1
;;;411    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002a  4825              LDR      r0,|L17.192|
00002c  4925              LDR      r1,|L17.196|
00002e  6008              STR      r0,[r1,#0]  ; g_tUart2
;;;412    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000030  4825              LDR      r0,|L17.200|
000032  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;413    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000034  4825              LDR      r0,|L17.204|
000036  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;414    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000038  2001              MOVS     r0,#1
00003a  8188              STRH     r0,[r1,#0xc]
;;;415    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00003c  02c0              LSLS     r0,r0,#11
00003e  81c8              STRH     r0,[r1,#0xe]
;;;416    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000040  2000              MOVS     r0,#0
000042  8208              STRH     r0,[r1,#0x10]
;;;417    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000044  8248              STRH     r0,[r1,#0x12]
;;;418    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000046  82c8              STRH     r0,[r1,#0x16]
;;;419    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
000048  8308              STRH     r0,[r1,#0x18]
;;;420    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004a  8348              STRH     r0,[r1,#0x1a]
;;;421    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
00004c  8288              STRH     r0,[r1,#0x14]
;;;422    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
00004e  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;423    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
000050  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;424    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000052  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;425    #endif
;;;426    
;;;427    #if UART3_FIFO_EN == 1
;;;428    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
000054  481e              LDR      r0,|L17.208|
000056  491f              LDR      r1,|L17.212|
000058  6008              STR      r0,[r1,#0]  ; g_tUart3
;;;429    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
00005a  481f              LDR      r0,|L17.216|
00005c  6048              STR      r0,[r1,#4]  ; g_tUart3
;;;430    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
00005e  481f              LDR      r0,|L17.220|
000060  6088              STR      r0,[r1,#8]  ; g_tUart3
;;;431    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000062  f44f6080          MOV      r0,#0x400
000066  8188              STRH     r0,[r1,#0xc]
;;;432    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000068  81c8              STRH     r0,[r1,#0xe]
;;;433    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
00006a  2000              MOVS     r0,#0
00006c  8208              STRH     r0,[r1,#0x10]
;;;434    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
00006e  8248              STRH     r0,[r1,#0x12]
;;;435    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
000070  82c8              STRH     r0,[r1,#0x16]
;;;436    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
000072  8308              STRH     r0,[r1,#0x18]
;;;437    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
000074  8348              STRH     r0,[r1,#0x1a]
;;;438    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
000076  8288              STRH     r0,[r1,#0x14]
;;;439    	g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
000078  4819              LDR      r0,|L17.224|
00007a  61c8              STR      r0,[r1,#0x1c]  ; g_tUart3
;;;440    	g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
00007c  4819              LDR      r0,|L17.228|
00007e  6208              STR      r0,[r1,#0x20]  ; g_tUart3
;;;441    	g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
000080  4819              LDR      r0,|L17.232|
000082  6248              STR      r0,[r1,#0x24]  ; g_tUart3
;;;442    #endif
;;;443    
;;;444    #if UART4_FIFO_EN == 1
;;;445    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;446    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;447    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;448    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;449    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;450    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;451    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;452    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;453    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;454    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;455    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;456    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;457    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;458    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;459    #endif
;;;460    
;;;461    #if UART5_FIFO_EN == 1
;;;462    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;463    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;464    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;465    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;466    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;467    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;468    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;469    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;470    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;471    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;472    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;473    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;474    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;475    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;476    #endif
;;;477    
;;;478    
;;;479    #if UART6_FIFO_EN == 1
;;;480    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
000084  4819              LDR      r0,|L17.236|
000086  491a              LDR      r1,|L17.240|
000088  6008              STR      r0,[r1,#0]  ; g_tUart6
;;;481    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
00008a  481a              LDR      r0,|L17.244|
00008c  6048              STR      r0,[r1,#4]  ; g_tUart6
;;;482    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
00008e  481a              LDR      r0,|L17.248|
000090  6088              STR      r0,[r1,#8]  ; g_tUart6
;;;483    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000092  f44f6080          MOV      r0,#0x400
000096  8188              STRH     r0,[r1,#0xc]
;;;484    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000098  81c8              STRH     r0,[r1,#0xe]
;;;485    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
00009a  2000              MOVS     r0,#0
00009c  8208              STRH     r0,[r1,#0x10]
;;;486    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
00009e  8248              STRH     r0,[r1,#0x12]
;;;487    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
0000a0  82c8              STRH     r0,[r1,#0x16]
;;;488    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
0000a2  8308              STRH     r0,[r1,#0x18]
;;;489    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
0000a4  8348              STRH     r0,[r1,#0x1a]
;;;490    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
0000a6  8288              STRH     r0,[r1,#0x14]
;;;491    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
0000a8  61c8              STR      r0,[r1,#0x1c]  ; g_tUart6
;;;492    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
0000aa  6208              STR      r0,[r1,#0x20]  ; g_tUart6
;;;493    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
0000ac  6248              STR      r0,[r1,#0x24]  ; g_tUart6
;;;494    #endif
;;;495    }
0000ae  4770              BX       lr
;;;496    
                          ENDP

                  |L17.176|
                          DCD      0x40011000
                  |L17.180|
                          DCD      g_tUart1
                  |L17.184|
                          DCD      g_TxBuf1
                  |L17.188|
                          DCD      g_RxBuf1
                  |L17.192|
                          DCD      0x40004400
                  |L17.196|
                          DCD      g_tUart2
                  |L17.200|
                          DCD      g_TxBuf2
                  |L17.204|
                          DCD      g_RxBuf2
                  |L17.208|
                          DCD      0x40004800
                  |L17.212|
                          DCD      g_tUart3
                  |L17.216|
                          DCD      g_TxBuf3
                  |L17.220|
                          DCD      g_RxBuf3
                  |L17.224|
                          DCD      RS485_SendBefor
                  |L17.228|
                          DCD      RS485_SendOver
                  |L17.232|
                          DCD      RS485_ReciveNew
                  |L17.236|
                          DCD      0x40011400
                  |L17.240|
                          DCD      g_tUart6
                  |L17.244|
                          DCD      g_TxBuf6
                  |L17.248|
                          DCD      g_RxBuf6

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;193     */
;;;194    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;195    {
;;;196      register uint32_t __regPriMask         __ASM("primask");
;;;197      __regPriMask = (priMask);
;;;198    }
000004  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;79     */
;;;80     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;81     {
;;;82     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;83     
;;;84     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;85     
;;;86     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;87     
;;;88     	ConfigUartNVIC();	/* 配置串口中断 */
00000e  f7fffffe          BL       ConfigUartNVIC
;;;89     }
000012  bd10              POP      {r4,pc}
;;;90     
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;297    */
;;;298    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;299    {
000002  4604              MOV      r4,r0
;;;300    	USART_InitTypeDef USART_InitStructure;
;;;301    
;;;302    	/* 第2步： 配置串口硬件参数 */
;;;303    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;304    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;305    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;306    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;307    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;308    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;309    	USART_Init(USART3, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L20.40|
000022  f7fffffe          BL       USART_Init
;;;310    }
000026  bd1f              POP      {r0-r4,pc}
;;;311    
                          ENDP

                  |L20.40|
                          DCD      0x40004800

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;250    */
;;;251    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;252    {
000002  4603              MOV      r3,r0
;;;253    	UART_T *pUart;
;;;254    
;;;255    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;256    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L21.16|
                  |L21.14|
;;;257    	{
;;;258    		return;
;;;259    	}
;;;260    
;;;261    	pUart->usRxWrite = 0;
;;;262    	pUart->usRxRead = 0;
;;;263    	pUart->usRxCount = 0;
;;;264    }
00000e  bd00              POP      {pc}
                  |L21.16|
000010  2000              MOVS     r0,#0                 ;261
000012  82d0              STRH     r0,[r2,#0x16]         ;261
000014  8310              STRH     r0,[r2,#0x18]         ;262
000016  8350              STRH     r0,[r2,#0x1a]         ;263
000018  bf00              NOP      
00001a  e7f8              B        |L21.14|
;;;265    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;227    */
;;;228    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;229    {
000002  4603              MOV      r3,r0
;;;230    	UART_T *pUart;
;;;231    
;;;232    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;233    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L22.16|
                  |L22.14|
;;;234    	{
;;;235    		return;
;;;236    	}
;;;237    
;;;238    	pUart->usTxWrite = 0;
;;;239    	pUart->usTxRead = 0;
;;;240    	pUart->usTxCount = 0;
;;;241    }
00000e  bd00              POP      {pc}
                  |L22.16|
000010  2000              MOVS     r0,#0                 ;238
000012  8210              STRH     r0,[r2,#0x10]         ;238
000014  8250              STRH     r0,[r2,#0x12]         ;239
000016  8290              STRH     r0,[r2,#0x14]         ;240
000018  bf00              NOP      
00001a  e7f8              B        |L22.14|
;;;242    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;206    */
;;;207    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;208    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;209    	UART_T *pUart;
;;;210    
;;;211    	pUart = ComToUart(_ucPort); //功能说明: 将COM端口号转换为UART指针
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;212    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L23.20|
;;;213    	{
;;;214    		return 0;
000010  2000              MOVS     r0,#0
                  |L23.18|
;;;215    	}
;;;216    
;;;217    	return UartGetChar(pUart, _pByte);
;;;218    }
000012  bd70              POP      {r4-r6,pc}
                  |L23.20|
000014  4631              MOV      r1,r6                 ;217
000016  4620              MOV      r0,r4                 ;217
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L23.18|
;;;219    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;165    */
;;;166    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;167    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;168    	UART_T *pUart;
;;;169    
;;;170    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;171    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L24.24|
                  |L24.20|
;;;172    	{
;;;173    		return;
;;;174    	}
;;;175    
;;;176    	if (pUart->SendBefor != 0)
;;;177    	{
;;;178    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;179    	}
;;;180    
;;;181    	UartSend(pUart, _ucaBuf, _usLen);
;;;182    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L24.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;176
00001a  b108              CBZ      r0,|L24.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;178
00001e  4780              BLX      r0                    ;178
                  |L24.32|
000020  463a              MOV      r2,r7                 ;181
000022  4631              MOV      r1,r6                 ;181
000024  4620              MOV      r0,r4                 ;181
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L24.20|
;;;183    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;192    */
;;;193    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;194    {
000002  4604              MOV      r4,r0
;;;195    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;196    }
00000e  bd1c              POP      {r2-r4,pc}
;;;197    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1275   */
;;;1276   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1277   {
000002  4604              MOV      r4,r0
;;;1278   
;;;1279   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1280   	uint8_t ucData;
;;;1281   
;;;1282   	while(comGetChar(COM1, &ucData) == 0);
000004  bf00              NOP      
                  |L26.6|
000006  4669              MOV      r1,sp
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L26.6|
;;;1283   
;;;1284   	return ucData;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;1285   #else
;;;1286   	/* 等待串口1输入数据 */
;;;1287   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1288   
;;;1289   	return (int)USART_ReceiveData(USART1);
;;;1290   #endif
;;;1291   }
000016  bd38              POP      {r3-r5,pc}
;;;1292   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1249   */
;;;1250   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1251   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1252   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1253   	comSendChar(COM1, ch);
000006  b2e1              UXTB     r1,r4
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comSendChar
;;;1254   
;;;1255   	return ch;
00000e  4620              MOV      r0,r4
;;;1256   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1257   	/* 写一个字节到USART1 */
;;;1258   	USART_SendData(USART1, (uint8_t) ch);
;;;1259   
;;;1260   	/* 等待发送结束 */
;;;1261   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;1262   	{}
;;;1263   
;;;1264   	return ch;
;;;1265   #endif
;;;1266   }
000010  bd70              POP      {r4-r6,pc}
;;;1267   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_RX_BUF
                          %        200
                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024
                  g_tUart2
                          %        40
                  g_RxBuf2
                          %        2048
                  g_tUart3
                          %        40
                  g_TxBuf3
                          %        1024
                  g_RxBuf3
                          %        1024
                  g_tUart6
                          %        40
                  g_TxBuf6
                          %        1024
                  g_RxBuf6
                          %        1024

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_STA
000000  0000              DCW      0x0000
                  g_TxBuf2
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_7cc17ae7____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_7cc17ae7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_7cc17ae7____REVSH|
#line 144
|__asm___15_bsp_uart_fifo_c_7cc17ae7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_7cc17ae7____RRX|
#line 300
|__asm___15_bsp_uart_fifo_c_7cc17ae7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
